# 06장 응용 서비스와 표현 영역

## 6.1 표현 영역와 응용 영역
- 응용 영역과 표현 영역이 사용자와 도메인을 연결해 주는 **매개체 역할**을 한다.
- 표현 영역
    - 사용자의 요청을 해석한다. (사용자와 상호작용)
    - **응용 서비스가 요구하는 형식으로 사용자 요청을 변환**한다.
    - 예) 사용자의 요청을 받은 표현 영역은 URL, 요청 파라미터, 쿠키, 헤더 등을 이용해서 사용자가 실행하고 싶은 기능을 판별하고, 그 기능을 제공하는 응용 서비스를 실행한다.
- 응용 영역
    - 실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 **서비스**이다.
    - 표현 영역에 의존하지 않는다.
    - 단지 기능 실행에 필요한 입력 값을 받고 실행 결과만 리턴하면 될 뿐이다.
    - 예) 사용자가 회원 가입을 요청했다면 실제 그 요청을 위한 기능을 제공하는 주체는 **응용 서비스에 위치**한다.


## 6.2 응용 서비스의 역할
- 응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리에서 **도메인 객체**를 가져와 사용한다.
- 응용 서비스는 **도메인 영역과 표현 영역을 연결해 주는 창구 역할**을 한다.
- 응용 서비스가 복잡하다면 **응용 서비스에서 도메인 로직의 일부를 구현**하고 있을 가능성이 높다.
    - 코드 중복, 로직 분산 등 코드 품질에 안 좋은 영향을 줄 수 있다.
- 응용 서비스는 **트랜잭션 처리도 담당**한다.
    - **도메인의 상태 변경을 트랜잭션으로 처리**해야 한다.


### 6.2.1 도메인 로직 넣지 않기
- 도메인 로직은 도메인 영역에 위치하고, 응용 서비스는 도메인 로직을 구현하지 않는다.
    - 예) 암호 변경 시 기존 암호를 올바르게 입력했는지를 확인 하는 것은 **도메인의 핵심 로직**이기 때문에, **응용 서비스에서 이 로직을 구현**하면 안 된다.
- **도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현**하면 코드 품질에 문제가 발생한다.
    - 첫 번째 문제 : 코드의 응집성이 떨어진다.
        - 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고, 서로 다른 영역에 위치한다는 것은 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 의미한다.
    - 두 번째 문제 : 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.(중복 코드 작성)
        - 도메인 영역에 해당 도메인 관련 기능을 구현했으면 응용 서비스는 그 기능을 사용하기만 하면 된다.
    - 위의 **두 가지 문제(응집도가 떨어지고, 코드 중복이 발생)는 결과적으로 코드 변경을 어렵게 만든다.**
        - 변경이 어렵다는 것은 그 만큼 소프트웨어의 가치가 떨어진다는 것을 **의미**
        - 소프트웨어의 가치를 높이려면 도메인 로직을 도메인 영역에 모아서 코드 중복을 줄이고 **응집도**를 높여야 한다.


## 6.3 응용 서비스의 구현
- 응용 서비스는 표현 영역과 도메인 영역을 연결하는 **매개체 역할**을 하는데 이는 디자인 패턴에서 **파사드**와 같은 역할을 한다.
- 응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 **응용 서비스의 구현은 어렵지 않다.**

### 6.3.1 응용 서비스의 크기
- 응용 서비스의 구현 방식
    - **한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기**
        - 장점
            - **한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점**이 있다.
        - 단점
            - 한 서비스 클래스의 크기(코드 줄 수)가 커진다.
                - 코드 크기가 커지면 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아지게 되는데, 결과적으로 관련 없는 코드가 뒤섞여 코드를 이해하는 데 방해가 된다.
            - 한 클래스에 코드가 모이기 시작하면, 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 된다.
                - 이것은 코드를 점점 얽히게 만들어 코드 품질을 낮추는 결과를 초래한다.
    - **구분되는 기능별로 응용 서비스 클래스를 따로 구현하기**
        - 한 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현한다.
        - **✅필자의 선호 방식✅**
        - 장점
            - 한 클래스에 관련 긴으을 모두 구현하는 것과 비교해서 **코드 품질을 일정 수준으로 유지하는 데 도움**이 된다.
            - **각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.**
        - 단점
            - 클래스 개수가 많아진다.
            - **각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성**이 있다.

### 6.3.2 응용 서비스의 인터페이스와 클래스
- **응용 서비스를 구현할 때 논쟁이 될 만한 것이 인터페이스가 필요한 지**이다.
    - 인터페이스가 필요한 몇 가지 상황 중 하나는 구현 클래스가 여러 개인 경우.
        - 하지만 응용 서비스는 런타임에 교체하는 경우가 거의 없고, 한 응용 서비스의 구현 클래스가 두 개인 경우도 드물다.
    - 인터페이스와 클래스를 따로 구현하면 **소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조가 복잡**해진다.
    - 따라서 **인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 선택이라고 볼 수는 없다.**

### 6.3.3 메서드 파라미터와 값 리턴
- 응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행 하는 데 필요한 값을 파라미터로 전달받아야 한다.
- 응용 서비스는 **파라미터로 전달받은 데이터를 사용해서 필요한 기능을 구현**하면 된다.
    - 스프링 MVC와 같은 웹 프레임워크는 **자바 객체로 변환 하는 기능을 제공하므로, 데이터 전달을 위한 별도의 클래스를 사용하는 것이 편리**하다.
- **응용 서비스의 결과를 표현 영역에서 사용해야 하면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴**한다.
    - 예) 식별자
    - 응용 서비스에서 애그리거트 자체를 리턴하는 방식은 코딩은 편할 수 있지만, **도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다.**
        - 이것은 **기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인**이 된다.
    - 응용 서비스는 **표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법**이다.

### 6.3.4 표현 영역에 의존하지 않기
- 응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 **표현 영역과 관련된 타입을 사용하면 안 된다는 점**이다.
    - 예) `HttpServletRequest`, `HttpSession`
- 응용 서비스에서 표현 영역에 대한 의존이 발생하면 생기는 문제점
    - 응용 서비스에서 표현 영역에 대한 의존이 발생하면 **응용 서비스만 단독으로 테스트하기가 어려워진다.**
    - 표현 영역의 구현이 변경되면 **응용 서비스의 구현도 함께 변경해야 하는 문제가 발생**한다.
    - ⚠️**응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다는 것**이다.⚠️
        - 표현 영역의 상태에 해당하는 `HttpSession`과 `쿠키`를 응용 서비스에서 변경해버리면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 추적이 어려워진다.
        - **표현 영역의 응집도가 깨지는 것**이다.
        - **코드 유지 보수 비용을 증가시키는 원인**이다.

### 6.3.5 트랜잭션 처리
- **트랜잭션을 관리하는 것은 응용 서비스의 중요한 역할**이다.
- **프레임워크가 제공하는 트랜잭션 기능을 적극 사용하는 것**이 좋다.
    - 프레임워크가 제공하는 규칙을 따르면 간단한 설정만으로 트랜잭션을 시작하여 커밋하고 익셉션이 발생하면 롤백 할 수 있다.
    - 예) 스프링은 `@Transactional`이 적용된 메서드가 `RuntimeException`을 발생시키면 트랜잭션을 롤백하고, 그렇지 않으면 커밋하므로 이 규칙에 따라 코드를 작성하면 **트랜잭션 처리 코드를 간결하게 유지**할 수 있다.


## 6.4 표현 영역
- 표현 영역의 책임
    - **사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어**한다.
        - 웹 서비스의 표현 영역은 **사용자가 요청한 내용을 응답으로 제공**한다.
        - 표현 영역은 **응용 서비스를 이용해서 표현 영역의 요청을 처리하고, 그 결과를 응답으로 전송**한다.
    - **사용자의 요청을 알맞은 요청 서비스에 전달하고 결과를 사용자에게 제공**한다.
        - 표현 영역은 **사용자의 요청 데이터를 응용 서비스가 요구하는 형식으로 변환하고 응용 서비스의 결과를 사용자에게 응답할 수 있는 형식으로 변환**한다.
        - **응용 서비스의 실행 결과를 사용자에게 알맞은 형식으로 제공하는 것도 표현 영역의 몫**이다.
        - 예) 응용 서비스에서 익셉션이 발생 시 에러 코드를 설정하는데 표현 영역의 뷰는 이 에러 코드에 알맞은 처리를 하게 된다.
    - **사용자의 세션을 관리**한다.
        - **웹은 쿠키나 서버 세션을 이용해서 사용자의 연결 상태를 관리**한다.


## 6.5 값 검증
- 값 검증은 **표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다.**
    - 원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.
- **표현 영역에서만 수행했을 경우**
    - 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받기 위해 다소 번잡한 코드를 작성해야 한다.
- **응용 서비스에서만 수행했을 경우**
    - **사용자에게 좋지 않은 경험을 제공**한다.
        - 예) 응용 서비스에서 값을 검사하는 시점에 첫 번째 값이 올바르지 않아 익셉션이 발생시키면 나머지 항목에 대해서는 값 검사를 하지 않기 때문.
- **표현 영역과 응용 서비스가 값 검사를 나누어 수행**
    - **표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 ID 중복 여부와 같은 논리적 오류만 검사**하면 된다.
    - **응용 서비스를 사용하는 표현 영역 코드가 한 곳이면 구현의 편리함을 위해 다음과 같이 역할을 나누어 검증을 수행** 할 수 있다.
        - 표현 영역 : 필수 값, 값의 형식, 범위 등을 검증한다.
        - 응용 서비스 : **데이터의 존재 유무와 같은 논리적 오류를 검증**한다.
- **✅필자의 조언✅**
    - **요즘은 가능하면 응용 서비스에서 필수 값 검증과 논리적인 검증을 모두 하는 편**이다.
        - 장점 : 응용 서비스의 완성도가 높아진다.
        - 단점 : 작성할 코드가 늘어나는 불편함.


## 6.6 권한 검사
- 개발 하는 시스템마다 권한의 복잡도가 다르다.
- 이런 다양한 상황을 충족하기 위해 **스프링 시큐리티 같은 프레임 워크는 유연하고 확장 가능한 구조를 가지고 있지만, 그 만큼 복잡하다는 것을 의미**하기도 한다.
- **보안 프레임워크에 대한 이해가 부족하면 프레임워크를 무턱대고 도입하는 것보다 개발할 시스템에 맞는 권한 검사 기능을 구현하는 것이 시스템 유지 보수에 유리**할 수 있다.
- 권한 검사를 수행하는 곳
    - 표현 영역
        - **인증된 사용자인지 아닌지 검사하는 것**
        - **서블릿 필터**에서 사용자의 인증 정보를 생성하고 인증 여부를 검사한다.
        - 예) 회원 정보 변경 기능 : 회원 정보 변경과 관련된 URL은 인증된 사용자만 접근해야 한다.
    - 응용 서비스
        - URL 만으로 접근 제어를 할 수 없는 경우.
        - 예) 스프링 시큐리티는 **AOP를 활용해서 애너테이션으로 서비스 메서드에 대한 권한 검사를 할 수 있는 기능을 제공**
    - 도메인
        - 개별 도메인 객체 단위로 권한 검사를 해야 하는 경우는 **구현이 복잡**해진다.
        - 예) 게시글 삭제는 본인 또는 관리자 역할을 가진 사용자만 가능.
            - 응용 서비스의 메서드 수준에서 권한 검사를 할 수 없기 때문에 직접 권한 검사 로직을 구현
        - 스프링 시큐리티와 같은 보안 프레임워크를 확정해서 개별 도메인 객체 수준의 권한 검사 기능을 프레임워크에 통합할 수도 있다.
            - **도메인에 맞게 보안 프레임워크를 확장하려면 프레임워크에 대한 높은 이해가 필요**하다.
            - 이해도가 높지 않아 프레임워크 확장을 원하는 수준으로 할 수 없다면 프레임워크를 사용하는 대신 **도메인에 맞는 권한 기능을 직접 구현하는 것이 코드 유지 보수에 유리**하다.


## 6.7 조회 전용 기능과 응용 서비스
- 서비스에서 조회 전용 기능을 사용하면 **서비스 코드가 단순히 조회 전용 기능을 호출하는 형태**로 끝날 수 있다.
    - 서비스에서 수행하는 추가적인 로직이 없을뿐더러 단일 쿼리만 실행하는 조회 전용 기능이어서 트랜잭션이 필요하지도 않다.
    - 이 경우에는 **굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 문제가 없다.**
- **응용 서비스가 사용자 요청 기능을 실행하는 데 별다른 기여를 하지 못한다면 굳이 서비스를 만들지 않아도 된다.**