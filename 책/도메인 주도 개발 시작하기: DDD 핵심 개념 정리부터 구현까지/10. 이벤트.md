# 10장 이벤트

## 10.1 시스템 간 강결합 문제
- **바운디드 컨텍스트간의 강결합 때문에 발생하는 문제**
  - 도메인 기능에서 다른 도메인 서비스를 실행하는 경우.
    - 설계상 문제
      - 예) Order는 주문을 표현하는 도메인 객체인데 결제 도메인의 환불 관련 로직이 뒤섞이게 된다. (환불 기능이 바뀌면 Order도 영향을 받게 된다.)
    - 기능을 추가할 때 발생
      - 예) 기능을 추가할 때마다 파라미터가 함께 추가되면, 다른 로직이 더 많이 섞이고, 트랜잭션 처리가 더 복잡해진다.
  - 응용 서비스에서 외부에 있는 서비스를 호출하는 경우.
    - 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야 할지 애매하다.
      - 예) 환불 기능을 실행하는 과정에서 익셉션이 발생시 트랜잭션을 롤백해야 할까? 일단 커밋을 해야 할까?
- **이벤트**
  - 컨텍스트간의 강한 결합을 없앨 수 있는 방법.
  - 특히 **비동기 이벤트**를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.
  - 한번 익숙해지면 **모든 연동을 이벤트와 비동기로 처리하고 싶을 정도로 강력하고 매력적인 것이 이벤트**이다.


## 10.2 이벤트 개요
- 이벤트가 발생하는 것은 **상태가 변경됐다는 것을 의미**한다.
  - 이벤트는 발생하는 것에서 끝나지 않고, **이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현**한다.
- 도메인 모델에서도 UI 컴포넌트와 유사하게 **도메인의 상태 변경을 이벤트로 표현**할 수 있다.
  - '~할 때', '~가 발생하면', '만약 ~하면'과 같은 요구 사항은 **도메인의 상태 변경과 관련된 경우가 많고 이런 요구사항을 이벤트를 이용해서 구현**할 수 있다.

### 10.2.1 이벤트 관련 구성요소
![img.png](사진폴더/10/10.3%20이벤트%20관련%20구성요소.png)
- 도메인 모델에 이벤트를 도입하려면 네 개의 구성요소를 구현해야 한다.
  - **이벤트**
    - **발생한 이벤트에 대한 정보**를 담는다.
  - **이벤트 생성 주체**
    - **도메인 모델에서 이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체**이다.
  - **이벤트 디스패처(퍼블리셔)**
    - 이벤트 생성 주체와 이벤트 핸들러를 연결해주는 것.
    - 디스패처의 구현 방식에 따라 **이벤트 생성과 처리를 동기나 비동기로 실행**하게 된다.
  - **이벤트 핸들러(구독자)**
    - 이벤트 생성 주체가 발생한 이벤트에 반응한다.
    - 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.

### 10.2.2 이벤트의 구성
- 이벤트는 발생한 이벤트에 대한 정보를 담는다.
  - 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현
  - 이벤트 발생 시간
  - 추가 데이터 : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보
- 사용 예시
  - 이벤트
    ```java
    public class ShippingInfochangedEvent {
      private String orderNumber;
      private long timestamp;
      private ShinppingInfo newShippingInfo;
    }
    ```
    - 이벤트는 현재 기준으로 과거(바로 직전이라도)에 벌어진 것을 표현하기 때문에 이벤트 이름에는 **과거 시제를 사용**한다.
    - 이벤트는 이벤트 핸들러가 작업을 수행하는 데 필요한 데이터를 담아야 한다.
    - 이벤트는 데이터를 담아야 하지만 그렇다고 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없다.
  - 핸들러
    ```java
    public class ShippingInfoChangedHandler {
        
        @EventListener(ShippingInfoChangedEvent.class)
        public void handle(ShippingInfoChangedEvent evt) {
          shippingInfoSynchronizer.sync(
                  evt.getOrderNumber(),
                  evt.getNewShippingInfo());
        }
    }
    ```
    - 디스패처로부터 이벤트를 전달받아 필요한 작업을 수행한다.
    - 데이터가 부족하면 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 한다.

### 10.2.3 이벤트 용도
- **트리거**
  - **도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용**할 수 있다.
    - 예) 주문에서는 주문 취소 이벤트를 트리거로 사용하여 주문을 취소하면, 환불을 처리해야 할 때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다.
- **서로 다른 시스템간의 데이터 동기화**
  - 예) 주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.

### 10.2.4 이벤트 장점
![img.png](사진폴더/10/10.5%20구매%20취소에%20더%20이상%20환불%20로직%20없음.png)
- 이벤트를 사용하면 **서로 다른 도메인 로직이 섞이는 것을 방지**할 수 있다.  

![img.png](사진폴더/10/10.6%20이벤트%20핸들러를%20추가해도%20도메인%20로직에%20영향%20없이%20기능%20확장.png)
- 이벤트 핸들러를 사용하면 **기능 확장도 용이**하다.


## 10.3 이벤트, 핸들러 디스패처 구현
- **이벤트 클래스**
  - 이벤트를 표현한다.
- **디스패처**
  - 스프링이 제공하는 ApplicationEventPublisher를 이용한다.
- **Events**
  - 이벤트를 발행한다.
  - 이벤트 발행을 위해 ApplicationEventPublisher를 사용한다.
- **이벤트 핸들러**
  - 이벤트를 수신해서 처리한다.
  - 스플잉 제공하는 기능을 사용한다.

### 10.3.1 이벤트 클래스
- 이벤트 자체를 위한 상위 타입은 존재하지 않는다.
  - 원하는 클래스를 이벤트로 사용하면 된다.
- 이벤트는 과거에 벌어진 상태 변화나 사건을 의미하므로 이벤트 클래스의 이름을 결정할 때에는 **과거 시제**를 사용해야 한다는 점만 유의하면 된다.
- 이벤트 클래스는 **이벤트를 처리하는 데 필요한 최소한의 데이터를 포함**해야 한다.
  - 예) 주문 취소됨 이벤트는 적어도 주문번호를 포함해야 관련 핸들러에서 후속 처리를 할 수 있다.
- 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수 있다.
  - 예) 모든 이벤트가 발생 시간을 갖는다면 추상 클래스를 만들어 상속받도록 한다.

### 10.3.2 Evnets 클래스와 ApplicationEventPublisher
- 이벤트 발생과 출판을 위해 스프링이 제공하는 ApplicationEventPublisher를 사용.
  - 스프링 컨테이너는 ApplicationEventPublisher도 된다.

### 10.3.3 이벤트 발생과 이벤트 핸들러
 - 이벤트를 처리할 핸들러는 스프링이 제공하는 `@EvnetListener` 애너테이션을 사용해서 구현한다.

### 10.3.4 흐름 정리
![img.png](사진폴더/10/10.7%20이벤트%20처리%20흐름.png)
  - **코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행**하고 있다.
    - **도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행**된다.


## 10.4 동기 이벤트 처리 문제
- 외부 시스템과의 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법은 **이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계**하는 것이다.


## 10.5 비동기 이벤트 처리
- 비동기 이벤트 처리 구현하는 방법
  - **로컬 핸들러를 비동기로 실행하기**
  - **메시지 큐를 사용하기**
  - **이벤트 저장소와 이벤트 포워더 사용하기**
  - **이벤트 저장소와 이벤트 제공 API 사용하기**

### 10.5.1 로컬 핸들러 비동기 실행
- 이벤트 핸들러를 별도 스레드로 실행하는 방법.
  - 스프링이 제공하는 `@Async` 애너테이션을 사용하면 손쉽게 비동기로 이벤트 핸들러를 실행할 수 있다.
- 사용방법
  - `@EnableAsync 애너테이션을 사용해서 비동기 기능을 활성화한다.
  - 이벤트 핸들러 메서드에 `@Async` 애너테이션을 붙인다.

### 10.5.2 메시징 시스템을 이용한 비동기 구현
- **카프카나 래빗MQ와 같은 메시징 시스템**을 사용하는 것이다.
- 사용 방법

  ![img.png](사진폴더/10/10.8%20메시지%20큐를%20이용한%20이벤트%20비동기%20처리.png)
- 필요하다면 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 한다.
  - 도메인 기능을 실행한 결과를 DB에 반영하고, 이 과정에서 발생한 이벤트를 메시지 큐에 저장하는 것을 같은 트랜잭션 범위에서 실행하려면 **글로벌 트랜잭션**이 필요하다.
- **글로벌 트랜잭션**의 장단점
  - 장점 : 안전하게 이벤트를 메시지 큐에 전달할 수 있다.
  - 단점 : 전체 성능이 떨어진다. 글로벌 트랜잭션을 지원하지 않는 메시징 시스템도 있다.
- 메시지 큐를 사용하면 **보통 이벤트를 발생시키는 주체와 이벤트 핸들러가 별도 프로세스에서 동작**한다.
  - 이벤트 발생 JVM과 이벤트 처리 JVM이 다르다는 것을 의미한다.
- 대표적인 메시징 시스템
  - **래빗MQ**
    - 글로벌 트랜잭션 지원과 함께 클러스터와 고가용성을 지원하기 때문에 안정적으로 메시지를 전달할 수 있는 장점이 있다.
    - 다양한 개발 언어와 통신 프로토콜을 지원하고 있다.
  - **카프카**
    - 글로벌 트랜잭션을 지원하지 않지만 다른 메시징 시스템에 비해 높은 성능을 보여준다.

### 10.5.3 이벤트 저장소를 이용한 비동기 처리
- 이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 방법.
- 사용 방법
  - 포워더 방식

    ![img.png](사진폴더/10/10.9%20이벤트%20저장소와%20포워더를%20이용한%20비동기%20처리.png)
    - 이벤트가 발생하면 핸들러는 스토리지에 이벤트를 저장한다.
    - 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행한다.
    - 포워더는 **별도 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리**된다.
    - 이벤트를 물리적 저장소에 보관하기 때문에 핸들러가 이벤트 처리에 실패할 경우 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러를 실행하면 된다.
    - **이벤트를 어디까지 처리했는지 추적하는 역할이 포워더**
  - API 방식

    ![img.png](사진폴더/10/10.10%20API를%20이용해서%20이벤트를%20외부에%20제공하는%20방식.png)
    - 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져간다.
    - **이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억**해야 한다.
    - 클라이언트 API를 이용해서 언제든지 원하는 이벤트를 가져올 수 있기 때문에 이벤트 처리에 실패하면 다시 실패한 이벤트부터 읽어와 이벤트를 재처리할 수 있다.
    - API 서버에 장애가 발생한 경웨도 주기적으로 재시도를 해서 API 서버가 살아나면 이벤트를 처리할 수 있다.
    
- **도메인의 상태와 이벤트 저장소로 동일한 DB를 사용**한다.
  - **도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리**된다.
- **이벤트 저장소 구현**
  - 포워더 방식과 API 방식 모두 이벤트 저장소를 사용하므로 **이벤트를 저장할 저장소가 필요**하다.
  - 이벤트는 **과거에 벌어진 사건이므로 데이터가 변경되지 않기 때문에, 새로운 이벤트를 추가하는 기능과 조회하는 기능만 제공**된다.


## 10.6 이벤트 적용 시 추가 고려 사항
- **이벤트 소스를 EventEntity에 추가할지 여부**
  - 예) 이벤트 발생 주체애 대한 정보를 갖을지 말지.
- **포워더에서 전송 실패를 얼마나 허용할 것이냐**
  - 포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어와 전송을 시도한다.
    - 이때 계속 전송에 실패하면 나머지 이벤트를 전송할 수 없게 된다.
  - 포워더를 구현할 때는 **실패한 이벤트의 재전송 횟수 제한을 두어야 한다.
    - 예) 동일 이벤트를 전송하는 데 3회 실패했다면 해당 이벤트는 생략하고 다음 이벤트로 넘어간다는 등의 정책이 필요하다.
    - 참고) 처리에 실패한 이벤트를 물리적 저장소에 남겨두면 이후 실패 이유 분석이나 후 처리에 도움이 된다.
- **이벤트 손실**
  - 이벤트 저장소를 사용하는 방식은 **이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리 하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장**할 수 있다.
  - 하지만 로컬 핸들러를 이용해서 **이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실**하게 된다.
- **이벤트 순서**
  - 이벤트 발생 순서대로 외부 시스템에 전달해야 할 경우, 이벤트 저장소를 사용하는 것이 좋다.
    - 이벤트 저장소는 **발생 순서대로 저장하고 그 순서대로 이벤트 목록을 제공하기 때문**이다.
  - 하지만 메시징 시스템은 **사용 기술에 따라 이벤트 발생 순서와 메시지 전달 순서가 다를 수 있다.**
- **이벤트 재처리**
  - 동일한 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할지 결정해야 한다.
  - 가장 쉬운 방법은 **마지막으로 처리한 이벤트의 순번을 기억해 두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 것**이다.
    - 예) 회원 가입 신청 이벤트가 처음 도착하면 이메일을 발송하는데, 동일한 순번의 이벤트가 다시 들어오면 이메일을 발송하지 않는 방식으로 구현한다.
  - **멱등성**
    - **연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 멱등성**이라고 한다.
      - 예) 배송지 정보 변경 이벤트를 받아서 주소를 변경하는 핸들러는 그 이벤트를 한 번 처리하나 여러 번 처리하나 결과적으로 동일 주소를 값으로 갖는다.
    - 이벤트 핸들러가 **멱등성을 가지면 시스템 장애로 인해 같은 이벤트가 중복해서 발생해도 결과적으로 동일 상태**가 된다.
      - **이벤트 중복 발생이나 중복 처리에 대한 부담을 줄여준다.**

### 10.6.1 이벤트 처리와 DB 트랜잭션 고려
- 이벤트를 처리할 때는 **DB 트랜잭션을 함께 고려**해야 한다.
- 이벤트 처리와 DB 트랜잭션을 고려하지 않았을 때 발생하는 문제
  - 이벤트 발생과 이벤트 처리를 동기로 실행할 때의 흐름

    ![img.png](사진폴더/10/10.14%20이벤트%20발생과%20이벤트%20처리를%20동기로%20실행할%20때의%20흐름.png)
    - 12번 과정까지 다 성공하고 13번 과정에서 DB를 업데이트하는 데 실패하는 상황
    - 다 성공하고 13번 과정에서 실패하면 결제는 취소됐는 데 DB에는 주문이 취소되지 않는 상태로 남게된다.
  - 비동기로 처리할 때의 실행 흐름

    ![img.png](사진폴더/10/10.15%20비동기로%20처리할%20때의%20실행%20흐름.png)
    - DB 업데이트와 트랜잭션을 다 커밋한 뒤에 환불 로직인 12번 과정에서 외부 API 호출에 실패하면 DB에는 주문이 취소된 상태로 데이터가 바뀌었는데 결제는 취소되지 않는 상태로 남게 된다.
- 이벤트 처리를 동기로 하든 비동기로 하든 **이벤트 처리 실패와 트랜잭션 실패를 함께 고려**해야 한다.
- **트랜잭션 실패와 이벤트 처리 실패를 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움**이 된다.
  - 경우의 수를 줄이는 법은 **트랜잭션이 설공할 때만 이벤트 핸들러를 실행**하면 된다.
    - 스프링 - `@TransactionalEventListener` 애너테이션 지원
      - 스프링은 **트랜잭션 커밋에 성공한 뒤에 핸들러 메서드를 실행**한다.
      - **중간에 에러가 발생해서 트랜잭션이 롤백 되면 핸들러 메서드를 실행하지 않는다.**
      - 이 기능을 사용하면 **이벤트 핸들러가 실행했는데 트랜잭션이 롤백 되는 상황은 발생하지 않는다.**
    - **이벤트 저장소로 DB를 사용**
      - **이벤트 발생 코드와 이벤트 저장처리를 한 트랜잭션으로 처리**하면 된다.
      - 트랜잭션이 성공할 때만 이벤트가 DB에 저장되므로, 트랜잭션은 실패했는데 이벤트 핸들러가 실행되는 상황은 발생하지 않는다.
  - **트랜잭션이 성공할 때만 이벤트 핸들러를 실행하게 되면 트랜잭션 실패에 대한 경우의 수가 줄어 이제 이벤트 처리 실패만 고민**하면 된다.
    - **이벤트 특성에 따라 재처리 방식을 결정**하면 된다.
