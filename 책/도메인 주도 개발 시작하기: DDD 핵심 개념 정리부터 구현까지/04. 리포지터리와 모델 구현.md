# 04장 리포지터리와 모델 구현

## 4.1 JPA를 이용한 리포지터리 구현
- 도메인 모델과 리포지터리를 구현할 때 선호하는 기술을 꼽자면 JPA를 들 수 있다.
- 데이터 보관소로 RDBMS를 사용할 때, 객체 기반의 도메인 모델과 관계형 데이터 모델간의 매핑을 처리하는 기술로 ORM 만한 것이 없다.

### 4.1.1 모듈 위치
![img.png](사진폴더/04/4.1%20DIP에%20따라%20리포지터리%20구현%20클래스는%20인프라스트럭처%20영역에%20위치한다.png)
- 리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.
- 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

### 4.1.2 리포지터리 기본 기능 구현
![img.png](사진폴더/04/4.2%20리포지터리.png)
- 리포지터리가 제공하는 기본 기능
  - ID로 애그리거트 조회하기
  - 애그리거트 저장하기
- 인터페이스는 **애그리거트 루트를 기준으로 작성**한다.
- JPA를 사용하면 **트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영**하기 때문에, 애그리거틀르 수정한 결과를 저장소에 반영하는 메서드를 추가할 필요없다.
  - 메서드 실행이 끝나면 트랜잭션을 커밋하는데 이때 JPA는 트랜잭션 범위에서 변경된 객체의 데이터를 DB에 반영하기 위해 UPDATE 쿼리를 실행한다.


## 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현
- 스프링 데이터 JPA는 **지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어 스프링 빈으로 등록**해준다.
- 스프링 데이터 JPA를 사용하려면 지정한 규칙에 맞게 메서드를 작성해야 한다.
  - 저장 메서드
    - `Order save(Order entity)`
    - `void save(Order entity`
  - 엔티티 조회 메서드
    - `Order findById(OrderNo id)`
    - `Optional<Order> findById(OrderNo id)`
  - 특정 프로퍼티를 이용한 엔티티 조회 메서드
    - `List<Order> findByOrderer(Orderer orderer)`
  - 중첩 프로퍼티를 이용한 엔티티 조회 메서드
    - `List<Order> findByOrdererMemberId(MemberId memberId)`
  - 엔티티 삭제 메서드
    - `void delete(Order order)`
    - `void deleteById(OrderNo id)`

## 4.3 매핑 구현

### 4.3.1 엔티티와 밸류 기본 매핑 구현
- 애그리거트와 JPA 매핑을 위한 기본 규칙
  - 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정
- 한 테이블에 엔티티와 밸류 데이터가 같이 있다면
  - 밸류는 @Embeddable로 매핑 설정한다.
  - 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.
- **루트 엔티티와 루트 엔티티에 속한 밸류를 한 테이블로 매핑**
  ![img.png](사진폴더/04/4.3%20엔티티와%20밸류가%20한%20테이블로%20매핑.png)

### 4.3.2 기본 생성자
- 엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받는다.
- 객체가 불변 타입이면 **생성 시점에 필요한 값을 모두 전달받으므로 값을 변경하는 set 메서드를 제공하지 않는다.**
  - **클래스에 기본 생성자(파라미터가 없는)를 추가할 필요가 없다는 것을 의미**
- 하지만 **JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.**
  - **DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문**이다.
  - 이런 기술적인 제약으로 기본 생성자가 필요 없는 객체와 같은 불변 타입은 **다른 코드에서 기본 생성자를 사용하지 못하도록 protect로 선언**한다.
  (기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용한다.)

### 4.3.3 필드 접근 방식 사용
- JPA는 필드와 메서드의 두 가지 방식으로 매핑을 처리할 수 있다.
- 메서드 방식
  - 프로퍼티를 위한 get/set 메서드를 구현해야 한다.
  - 엔티티에 프로퍼티를 위한 공개 get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.
  - **특히 set메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인**이 될 수 있다.
  - 엔티티가 객체로서 제 역할을 하려면 **외부에 set 메서드 대신 의도가 잘 드러나는 기능을 제공**해야 한다.
  - **밸류 타입을 불변으로 구현하려면 set 메서드 자체가 필요 없는데, JPA의 구현 방식 때문에 공개 set 메서드를 추가하는 것도 좋지 않다.**
- 필드 방식
  - 객체가 제공할 기능을 중심으로 엔티티를 구현하게끔 유도한다.
  - 도메인 기능 구현 및 필요한 get 메서드 제공

### 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리
- **두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 칼럼에 매핑하려면 @Embeddable 애너테이션으로 처리할 수 없고, 이럴 때 사용하는 것이 AttributeConverter**이다.
- 예시)
  
    ![img.png](사진폴더/04/4.5%20Money를%20위한%20AttributeConverter%20구현.png)

### 4.3.5 밸류 컬렉션: 별도 테이블 매핑
- **엔티티는 List 타입을 이용해서 밸류 컬렉션을 프로퍼티로 지정**할 수 있다.
- 밸류 컬렉션을 별도 테이블로 매핑

   ![img.png](사진폴더/04/4.4%20밸류%20컬렉션을%20별도%20테이블로%20매핑.png)
    - 밸류 컬렉션을 저장하는 ORDER_LINE 테이블은 외부키(컬렉션이 속할 엔티티를 의미)를 이용해서 엔티티(루트)에 해당하는 PURCHASE_ORDER 테이블을 참조한다.
    - List 타입 컬렉션은 인덱스 값이 필요하므로 ORDER_LINE 테이블에는 인데스 값을 저장하기 위한 컬럼(line_idx)도 존재한다.
    - 밸류 컬렉션을 별도 테이블로 매핑할 때는 @ElementCollection과 @CollectionTable을 함께 사용한다.
      - OrderLinde 에는 List의 인덱스 값을 저장하기 위한 프로퍼티가 존재 하지 않는다.
        - **List 타입 자체가 인덱스를 갖고 있기 때문**이다.
        - JPA는 @OrderColumn 애너테이션을 이용해서 지정한 칼럼에 리스트의 인덱스 값을 저장한다.

### 4.3.6 밸류 컬렉션: 한 개 칼럼 매핑
- 밸류 컬렉션을 별도 테이블이 아닌 한 개 칼럼에 저장해야 할 때가 있다.
  - 예) 이메일 주소 목록을 Set으로 보관하고, DB에는 한 개 칼럼에 콤마로 구분해서 저장.
- **AttributeConverter를 사용하면 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑**할 수 있다.
  - **단 AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가**해야 한다.

### 4.3.7 밸류를 이용한 ID 매핑
- 식별자라는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수 있다.
- **밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점**이다.
  - 예) 1세대 시스템의 주문번호와 2세대 시스템의 주문번호를 구분하는 기능

### 4.3.8 별도 테이블에 저장하는 밸류 매핑
- 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 **밸류**이다.
- **루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심**해봐야 한다.
- 단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아니다.
  - 예) 주문 애그리거트도 주문상품을 별도 테이블에 저장하지만 주문상품 자체는 엔티티가 아니라 밸류이다.
- **특히 자신만의 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다.**
  - 예) 상품 자체에 대한 정보와 고객의 리뷰 (상품과 리뷰가 함께 생성되지 않고, 함께 변경되지 않기 때문)
- **애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법**
  - **고유 식별자를 갖는지를 확인하는 것**
  - **주의사항**
    - **식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안 된다.** 
    - **별도 테이블로 저장하고 테이블에 PK가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자**를 갖는 것은 아니기 때문이다.
      - 예) 게시글과 게시글 상세 테이블. (게시글의 특정 프로퍼티를 별도 테이블에 보관한 것으로 접근해야 한다.)
- 성능 문제
  - 예) 게시글 목록을 보여주는 화면은 게시글 테이블의 정보만 있으면 된다.
  - 실제로 사용 시에는 게시글과 게시글 상세 테이블을 조인해서 가져오기 때문에, 이것은 원하는 결과가 아니다.
  - 이 문제를 해소하고자 게시글 상세 테이블을 엔티티로 매핑하고 게시글 엔티티에서 게시글 상세 엔티티로의 로딩을 지연 로딩 방식으로 설정할 수도 있다.
  - 하지만 이 방식은 **밸류인 모델을 엔티티로 만드는 것이므로 좋은 방법은 아니다.**

### 4.3.9 밸류 컬렉션을 @Entity로 매핑하기
- 개념적으로 밸류인데, 구현 기술의 한계나 팀 표준 때문에 @Entity를 사용해야 할 때도 있다.
  - 예) 제품의 이미지 업로드 방식에 따라 이미지 경로와 섬네일 이미 제공 여부가 달라진 경우.
    
    ![img.png](사진폴더/04/4.7%20계층%20구조를%20갖는%20밸류%20타입.png)
    - JPA는 @Embeddable 타입의 클래스 상속 매핑을 지원하지 않는다.
    - 상속 구조를 갖는 밸류 타입을 사용하려면 @Entity를 이용해서 상속 매핑으로 처리해야 한다.
    - 식별자 매핑과 구현 클래스를 구분하기 위한 타입 식별 칼럼을 추가해야 한다.
    - **이때 모델에서 해당 객체는 밸류이므로 상태를 변경하는 기능은 추가하지 않는다.**
    - **밸류이므로 독자적인 라이프 사이클을 갖지 않고, 제품에 완전히 의존한다.**
- @Entity에 대한 @OneToMany 매핑에서 컬렉션의 clear() 메서드를 호출하면 삭제 과정에서 효율적이지 않다.
  - 하이버네이트의 경우 @Entity를 위한 컬렉션 객체의 clear() 메서드를 호출하면 **select 쿼리로 대상 엔티티를 로딩**하고, 각 개별 에니팉에 대해 delete 쿼리를 실행한다.
  - 변경 빈도가 낮으면 괜찮지만 빈도가 높으면 전체 서비스 성능에 문제가 될 수 있다.
- 하이버네이트는 **@Embeddable 타입에 대한 컬렉션의 clear() 메서드를 호출하면 컬렉션에 속한 객체를 로딩하지 않고, 한 번의 delete 쿼리로 삭제 처리를 수행**한다.
- 코드 유지 보수와 성능의 두 가지 측면을 고려해서 **구현 방식을 선택**해야 한다.

### 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑
- 애그리거트 간 집합 연관은 성능 상의 이유로 피해야 하지만, 요구사항을 구현하는 데 집합 연관을 사용하는 것이 유리하다면 ID 참조를 이용한 단방향 집합 연관을 적용해볼 수 있다.
- 집합의 값에 밸류 대신 연관을 맺는 식별자가 온다는 점이다.
- @ElementCollection을 이용하기 때문에 상품를 삭제할 때 매핑에 사용한 조인 테이블의 데이터도 함께 삭제된다.
- 애그리거트를 직접 참조하는 방식을 사용했다면 영속성 전파나 로딩 전략을 고민해야 하는 데 ID 참조 방식을 사용함으로써 이런 고민을 없앨 수 있다.


## 4.4 애그리거트 로딩 전략
- JPA 매핑을 설정할 때 항상 기억해야 할 점은 **애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것**이다.
  - **애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태**여야 함을 의미한다.
- 조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 즉시 로딩을 설정하면 된다.
  - 항상 좋은 것은 아니다.
    - **컬렉션에서 사용 시 쿼리 결과에 중복을 발생**한다.
    - 조회 성능 문제 때문에 즉시 로딩 방식을 사용하지만, 이렇게 조회되는 데이터 개수가 많아지면 **즉시 로딩 방식을 사용할 때 성능(실행 빈도, 트래픽, 지연 로딩 시 실행 속도 등)을 검토**해봐야 한다.
- **애그리거트 내의 모든 연관을 즉시 로딩을으로 설정하지 않아도 되는 이유**
  - **애그리거트는 개념적으로 하나**여야 하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.
    - 애그리거트가 완전해야 하는 이유
      - **상태를 변경하는 기능을 실행 할 때 애그리거트 상태가 완전**해야 한다.
        - **JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.**
      - **표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요**하기 때문이다.
        - **별도의 조회 전용 긴으과 모델을 구현하는 방식을 사용하는 것이 더 유리**하다.
- **무조건 즉시 로딩이나 지연 로딩으로만 설정하기보다는 애그리거트에 맞게 즉시 로딩과 지연 로딩을 선택해야 한다.**
  - 지연 로딩은 즉시 로딩보다 쿼리 실행 횟수가 많아질 가능성이 더 높기 때문.


## 4.5 애그리거트의 영송석 전파
- 애그리거트가 **완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미**한다.
  - 저장 메서드는 애그리거트 루트만 저장하면 안 되고, 애그리거트에 속한 모든 객체를 저장해야 한다.
  - 삭제 메서드는 애그리거트 루트뿐만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.
- **@Embeddable 매핑 타입(밸류 타입)은 함께 저장되고 삭제되므로 cascade 설정을 추가로 설정하지 않아도 된다.**
- 반면에 **애그리거트에 속한 @Entity 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 시에 함께 처리되도록 설정**해야 한다.


## 4.6 식별자 생성 기능
- 식별자는 크게 세 가지 방식 중 하나로 생성한다.
  - 사용자가 직접 생성
    - 이메일 주소와 같이 사용자가 집접 식별자를 일력하는 경우는 식별자 생성 주체가 사용자이기 때문에 도메인 영역에서 식별자 생성 기능을 구현할 필요가 없다.
  - 도메인 로직으로 생성
    - 식별자 생성 규칙이 있다면 **엔티티를 생성할 때 식별자를 엔티티가 별도 서비스로 식별자 생성 기능을 분리**해야 한다.
    - **식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치**시켜야 한다.
    - 식별자 생성 규칙을 구현하기에 적합한 장소는 도메인서비스와 리포지터리다.
  - DB를 이용한 일련번호 사용
    - DB 자동 증가 칼럼을 식별자로 사용하면 식별자 매핑에서 @GeneratedValue를 사용한다.
    - 자동 증가 컬럼은 DB의 insert 쿼리를 실행해야 식별자가 생성되므로 도메인 객체를 리포지터리에 저장할 때 식별자가 생성된다.
    - JPA는 저장 시점에 생성한 식별자를 @Id로 매핑 한 프로퍼티/필드에 할당하므로 저장 이후에 엔티티의 식별자를 사용할 수 있다.
    - 자동 증가 컬럼 외에 JPA의 식별자 생성 기능을 사용하는 경우에도 마찬가지로 저장 시점에 식별자를 생성한다.


## 4.7 도메인 구현과 DIP
- **DIP를 적용하는 주된 이유는 저수준 구현이 변경되더라도 고수준이 영향을 받지 않도록 하기 위함**이다.
- 하지만 **리포지터리와 도메인 모델의 구현 기술을 거의 바뀌지 않는다.**
  - 저자는 JPA로 구현한 리포지터리 구현 기술을 마이바티스나 다른 기술로 변경한 적이 없고, RDBMS를 사용하다 몽고DB로 변경한 적도 없다고 한다.
- 변경이 거의 없는 상황에서 변경을 미리 대비하는 것은 과하다.
- **DIP를 완벽하게 지키면 좋겠지만 개발 편의성과 실용성을 가져가면서 구조적인 유연함은 어느 정도 유지**해야 한다.
- 복잡도를 높이지 않으면서(즉 JPA 애너테이션을 도메인 모델에 사용하면서) 기술에 따른 구현 제약이 낮다면 합리적인 선택이다.