# 3장 애그리거트

## 3.1 애그리거트
- 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고, 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
  
  ![img.png](사진폴더/03/3.2%20개별%20객체%20수준에서%20모델을%20바라보면%20상위%20수준에서%20관계를%20파악하기%20어렵다.png)
  - 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 **코드를 변경하고 확장하는 것이 어려워진다는 것을 의미**


- **애그리거트**는 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법
  
  ![img.png](사진폴더/03/3.3%20애그리거트는%20복잡한%20모델을%20관리하는%20기준을%20제공한다.png)
  - 수 많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
  - 모델을 이해하는 데 도움을 준 뿐만 아니라 **일관성을 관리하는 기준**도 된다.
    - 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.
    - 복잡도가 낮아지는 만큼 도메인 긴으을 확장하고 변경하는 데 필요한 노력(개발 시간)도 줄어든다.
- 도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 **애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거**한다.
- **애그리거트**는 경계를 갖는다.
  - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
  - 경계를 설정할 때 기본이 되는 것은 **도메인 규칙과 요구사항**이다.
  - ⚠️주의⚠️
    - 'A가 B를 갖는다.'로 해석할 수 있는 요구사항이 있다고 하더라고, 이것이 반드시 **A와 B가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다.**
    
    ![img.png](사진폴더/03/3.4%20예제.png)
    - 예) 상품 상세 페이지에 들어가면 상품 상세 정보와 함께 리뷰 내용을 보여줘야 한다는 요구사항
      - Product 엔티티와 Review 엔티티가 한 애그리거트에 속한다고 생각할 수 있지만, Product와 Review는 함께 생성되지 않고, 함께 변경되지도 않는다.
      - 게다가 Product를 변경하는 주체가 상품 담당자라면 Review를 생성하고 변경하는 주체는 고객이다.
- ⭐️저자의 경험⭐️
  - 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드물었다.


## 3.2 애그리거트 루트
- 애그리거트는 **여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안된다.**
  - 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- **애그리거트의 루트 엔티티**
  - 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리하는 주체.
  - **애그리거트 루트 엔티티는 애그리거트의 대표 엔티티다.**

### 3.2.1 도메인 규칙과 일관성
- 애그리거트 루트의 핵심 역할은 **애그리거트의 일관성이 깨지지 않도록 하는것이다.**
  - 이를 위해 **애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현**한다.
- 애그리거트 루트가 제공하는 메서드는 **도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현**해야 한다.
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다.
  - **애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인.**
  - 업무 규칙을 무시하고 직접 DB 테이블의 데이터를 수정하는 것과 같은 결과 (논리적인 데이터 일관성이 깨지게 되는 것)
- **애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음 두 가지를 습관적으로 적용**해야 한다.
  - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
    - 도메인의 의미나 의도를 표현하지 못하고 도메인 로직을 도메인 객체가 아닌 **응용 영역이나 표현 영역으로 분산**시킨다.
    - **도메인 로직이 한 곳에 응집되지 않으므로 코드를 유지 보수할 때에도 분석하고 수정하는 데 더 많은 시간이 필요**하다.
  - 밸류 타입은 불변으로 구현한다.
    - 공개 set 메서드를 만들지 않는 것의 연장
    - 애그리거트 외부에서 내부 상태를 함부로 바꾸지 못하므로 애그리거트의 일관성이 깨질 가능성이 줄어든다.
- **애그리거트 루트가 도메인 규칙을 올바르게 구현하면 애그리거트 전체의 일관성을 올바르게 유지**할 수 있다.

### 3.2.2 애그리거트 루트의 기능 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
  - 예) Order는 총 주문 금액을 구하기 위해 OrderLine 목록을 사용한다.
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니고 **기능 실행을 위임하기도 한다.**
  - 외부에서 애그리거트 내부 상태를 변경하면, 애그리거트 루트의 값과 내부 상태의 값이 일치하지 않을 수 있다.
  - 애그리거트 외부에서 애그리거트 내부 상태를 변경할 수 없도록 불변으로 구현해야 한다.
  - 팀 표준이나 구현 기술의 제약으로 불변으로 구현할 수 없다면 변경 기능을 패키지나 protected 범위로 한정해서 외부에서 실행할 수 없도록 제한하는 방법도 있다.

### 3.2.3 트랜잭션 범위
- 트랜잭션 범위는 작을수록 좋다.
  - 한 트래잭션이 **한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생**한다.
  - 잠금 대상(트랜잭션 충돌을 막기 위해 잠그는 대상)이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 의미하고 이것은 전체적인 성능(처리량)을 떨어뜨린다.
- 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
  - **애그리거트에서 다른 애그리거트를 변경하지 않는 것을 의미**한다.
  - 한 애그리거트에서 다른 애그리거트를 수정하면 결과적으로 두 개의 애그리거틀르 한 트랜잭션에서 수정하게 되므로, **애그리거트 내부에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안 된다.**
  - **애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하는 꼴**
  - 애그리거트는 **최대한 서로 독립적이어야 하는데 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아진다.**
  - 결합도가 높아지면 높아질수록 향후 수정 비용이 증가하므로 **애그리거트에서 다른 애그리거트의 상태를 변경하지 말아야 한다.**
- 도메인 이벤트를 사용하면 **한 트랜잭션에서 한 개의 애그리거트를 수정하면서 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성**할 수 있다.
- 한 트랜잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만, 다음 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
  - 팀 표준 : 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다.
  - 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
  - UI 구현의 편리 : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경해야 한다.


## 3.3 리포지터리와 애그리거트
- 애그리거트는 **개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재**한다.
- 어떤 기술을 이용해서 **리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향**을 받는다.
  - ORM 기술 중 하나인 JPA를 사용하면 데이터베이스 관계형 모델에 객체 도메인 모델을 맞춰야 할 때도 있다.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
  - **리포지터리에 애그리거트를 저장하면 애그리거트 전체를 영속화**해야 한다.
  - 동일하게 **애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공**해야 한다.
- 애그리거트를 영속화할 저장소를 무엇을 사용하든지 간에 **애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영**해야 한다.
  - 애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 일관성이 깨지므로 문제가 된다.
  - RDBMS를 이용해서 리포지터리를 구현하면 트랜잭션을 이용해서 애그리거트의 변경이 저장소에 반영되는 것을 보장할 수 있다.
  - 몽고DB를 사용하면 한 개 애그리거트를 한 개 문서에 저장함으로써 한 애그리거트의 변경을 손실 없이 저장소에 반영할 수 있다.


## 3.4 ID를 이용한 애그리거트 참조
- 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.

![img.png](사진폴더/03/3.6%20애그리거트%20루트에%20대한%20참조.png)
  - 애그리거트 루트에 대한 참조
    - 애그리거트 관리 주체는 **애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조**한다는 것과 같다.
    - 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.
    - 하지만 필드를 이용한 애그리거트 참조는 다음 문제를 야기한다.
      - 편한 탐색 오용
        - **애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다는 것이다.**
        - 한 애그리거트 내부에서 **다른 애그리거트 객체에 접근할 수 있다면 다른 애그리거트의 상태를 쉽게 변경**할 수 있게 된다.
        - 트랜잭셤 번위에서 언급한 것처럼 **한 애그리거트가 관리하는 범위는 자기 자신으로 한정**해야 한다.
        - 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 **애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.**
      - 성능에 대한 고민
        - 애그리거트를 직접 참조하면 **성능과 관련된 여러 가지 고민을 해야 한다는 것**이다.
        - 연관된 객체의 데이터를 함께 화면에 보여줘야 하면 즉시 로딩이 조회 성능이 유리하지만, 애그리거트의 상태를 변경하는 기능을 실행하는 경우에는 불필요한 객체를 함께 로딩할 필요가 없으므로 지연로딩이 유리할 수 있다.
      - 확장 어려움
        - **사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 하위 도메인별로 시스템을 분리**하기 시작한다.
        - 만약 한 하위 도메인은 마리아DB를 사용하고 다른 하위 도메인은 몽고DB를 사용하면, 더 이상 **다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미**한다.

![img.png](사진폴더/03/3.7%20ID를%20이용한%20간접%20참조.png)
- ID를 이용한 간접 참조
  - ID 참조를 사용하면 **모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결**된다.
  - **애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다.**
  - 애그리거트 간의 **의존을 제거하므로 응집도를 높여주는 효과**도 있다.
  - **다른 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 지연 로딩으로 할지 즉시로딩으로 할지 고민하지 않아도 되서, 구현 복잡도도 낮아진다.**
  - ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 **애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지**할 수 있다.
    - 외부 애그리거트를 직접 참조하지 않기 때문에 애초에 **한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없는 것**이다.

### 3.4.1 ID를 이용한 참조와 조회 성능
- 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제 될 수 있다.
  - '조회 대상이 N개 일 때 N개를 읽어오는 한 번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행한다'해서 이를 **N+1 조회 문제**라고 부른다.
  - ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만드는 데 지연 로딩과 관련된 대표적인 문제가 **N+1 조회 문제**이다.
  - 이 문제가 발생하지 않도록 하려면 **조인**을 사용해야 한다.
    - 조인을 사용 가장 쉬운 방법은 **ID 참조 방식을 객체 참조 방식으로 바꾸고 즉시 로딩을 사용하도록 매핑 설정을 바꾸는 것**이다.
    - 하지만 이 방식을 애그리거트 간 참조를 **ID 참조 방식에서 객체 참조 방식으로 다시 되돌리는 것**이다.
- ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 **조회 전용 쿼리를 사용**하면 된다.
  - 예를 들어 데이터 조회를 위한 별도 DAO를 만들고, DAO의 조회 메서드에서 조인을 이용해 한 번의 쿼리로 필요한 데이터를 즉시 로딩하면 된다.
- **쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야 한다면 조회를 위한 부분만 마이바티스와 같은 기술을 이용해서 구현**할 수도 있다.
- 애그리거트마다 서로 다른 저장소를 사용하면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.
  - 이때는 **조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성**한다.
    - **코드가 복잡해지는 단점이 있지만 시스템의 처리량을 높일 수 있다는 장점**이 있다.
    - 특히 한 대의 DB 장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 **캐시나 조회 전용 저장소는 필수로 선택해야 하는 기법**이다.

✅ 참고 ✅
- 처음 JPA를 사용하면 각 객체 간 모든 연관을 지연 로딩과 즉시 로딩으로 어떻게든 처리하고 싶은 욕구가 사로 잡힌다.
- 하지만 이것은 실용적이지 않고, ID를 이용해 애그리거트를 참조해도 한 번의 쿼리로 필요한 데이터를 로딩하는 것이 가능하다.


## 3.5 애그리거트 간 집합 연관
- 애그리거트 간 1-N과 M-N 연관은 컬렉션을 이용한 연관이다.
- 1-N 연관
  - 개념적으로 **애그리거트 간에 1-N 연관이 있더라도 이런 성능 문제 때문에 애그리거트 간의 1-N 연관을 실제 구현에 반영하지 않는다.**
    - 예) 카테고리에 속한 상품을 구할 필요가 있다면 상품 입장에서 자신이 속한 카테고리를 N-1로 연관 지어 구하면 된다.
- M-N 연관
  - 개념적으로 **양쪽 애그리거트에 컬렉션으로 연관**을 맺는다.
  - 개념적으로는 **상품과 카테고리의 양방향 M-N 연관이 존재하지만, 실제 구현에서는 상품에서 카테고리로의 단방향 M-N 연관만 적용**하면 된다.


## 3.6 애그리거트를 팩토리로 사용하기
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.
  - 예) Store 애그리거트에서 Product를 생성하는 기능
    - Product의 경우 제품을 생성한 Store의 식별자를 필요로 한다. (즉 Store의 데이터를 이용해서 Product를 생성한다.)
    - Product를 생성할 수 있는 조건을 판단할 때 Store의 상태를 이용한다. (예: Store가 차단되면 Product 등록 불가)
    - Store 애그리거트에서 Product 애그리거트를 생성하는 팩토리 역할을 한다.
    - **팩토리 역할을 하면서도 중요한 도메인 로직을 구현**하고 있다.
    - Store 애그리거트가 Product 애그리거트를 생성할 때 많은 정보를 알아야 한다면, Store 애그리거트에서 Product 애그리거트를 직접 생성하지 않고
    다른 팩토리에 위임하는 방법도 있다.
      - 다른 패곹리에 위임하더라도 차단 상태의 상점은 상품을 만들 수 없다는 **도메인 로직은 한 곳에 계속 위치한다.**
- 애그리거트를 팩토리로 사용할 때 얻을 수 있는 장점
 - **도메인 로직을 변경해도 응용 서비스에는 영향을 받지 않으며, 도메인 영역만 변경하면 된다.**
 - 도메인의 응집도가 높아진다.