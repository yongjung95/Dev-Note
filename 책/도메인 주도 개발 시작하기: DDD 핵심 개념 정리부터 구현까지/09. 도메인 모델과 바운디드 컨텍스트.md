# 09장 도메인 모델과 바운디드 컨텍스트

## 9.1 도메인 모델과 경계
- 처음 도메인 모델을 만들 때 빠지기 쉬운 함정이 **도메인을 완벽하게 표현하는 단일 모델을 만드는 시도**를 하는 것이다.
    - 한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에, **한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델**을 만들게 된다.
- 예) 상품
    - 카탈로그 - 상품 : 상품 이미지, 상품명, 상품 가격, 옵션 목록, 상세 설명과 같은 상품 정보
    - 재고 관리 - 상품 : 실존하는 개별 객체를 추적하기 위한 목적으로 상품을 사용
    - 카탈로그에서는 물리적으로 한 개인 상품이 재고 관리에서는 여러 개 존재할 수 있다.
- 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.
    - 예) 시스템을 사용하는 사람
        - 회원 도메인에서는 회원
        - 주문 도메인에서는 주문자
        - 배송 도메인에서는 보내는 사람
- 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 **올바른 방법이 아니며 표현할 수도 없다.**
- 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인 마다 모델을 만들어야 한다.
    - 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
    - 여러 하위 도메인의 모델이 섞이기 시작하면 **모델의 의미가 약해질 뿐만 아니라 여러 도메인의 모델이 서로 얽히기 때문에 각 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워**진다.
- 모델은 특정한 컨텍스트(문맥) 하에서 **완전한 의미**를 갖는다.
    - 예) 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 **의미가 서로 다르다.**
    - 구분 되는 경계를 갖는 컨텍스트를 DDD에서는 **바운디드 컨텍스트**라고 부른다.


## 9.2 바운디드 컨텍스트
- **모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.**
- 바운디드 컨텍스트는 **용어를 기준으로 구분**한다.
    - 예) 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 **컨텍스트를 분리**할 수 있다.
- 바운디드 컨텍스트는 **실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현**한다.
- 바운디드 컨텍스트의 구현 기준
    
    ![img.png](사진폴더/09/9.2%20조직%20구조에%20따라%20바운디드%20컨텍스트가%20결정된다.png)
    - **기업의 팀 조직 구조에 따라 결정**되기도 한다.
        - 예) 주문 하위 도메인이라도 주문을 처리하는 팀과 복잡한 결제 금액 계산 로직을 구현하는 팀 각각의 컨텍스트가 존재하게 된다.
    - 용어를 명확하게 구분하지 못해 두 하위 도메인을 하나의 바운디드 컨텍스트로 구현하기도 한다.
        - 예) 카탈로그와 재고 관리가 아직 명확하게 구분되지 않은 경우 두 하위 도메인을 하나의 바운디드 컨텍스트에 구현하기도 한다.

    ![img.png](사진폴더/09/9.3%20물리적인%20바운디드%20컨텍스트가%20한%20개이더라도%20내부적으로%20패키지를%20활용해서%20논리적으로%20바운디드%20컨텍스트를%20만든다.png)
    - **규모가 작은 기업은 전체 시스템을 한 개 팀에서 구현**할 때도 있다.
        - **여러 하위 도메인을 한 개의 바운디드 컨텍스트에서 구현**한다.
        - 주의점
            - 하위 도메인의 모델이 섞이지 않도록 하는 것.
                - 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해서 하위 도메인별로 기능을 확장하기 어렵게 되고, 이는 **서비스 경쟁력을 떨어뜨리는 원인**이 된다.
        - 해결방안
            - 한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 **하위 도메인마다 구분되는 패키지를 갖도록 구현**해야 한다.
                - 하위 도메인을 위한 모델이 서로 뒤섞이지 않고, 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.
- 바운디드 컨텍스트는 **도메인 모델을 구분하는 경계가 되기 때문에 바운디드 컨텍스트는 구현하는 하위 도메인에 알맞은 모델을 포함**한다.

  ![img.png](사진폴더/09/9.4%20바운디드%20컨텍스트는%20각자%20구현하는%20하위%20도메인에%20맞는%20모델을%20갖는다.png)
  - 예) 회원의 Member는 애그리거트 루트이지만, 주문의 Orderer는 밸류가 되고, 카탈로그의 Product는 상품이 속할 Category와 연관을 갖지만 재고의 Product는 카탈로그의 Category와 연관을 맺지 않는다.


## 9.3 바운디드 컨텍스트 구현
- 바운디드 컨텍스트는 **도메인 모델을 포함하여, 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처 영역, DB 테이블 모두 포함**한다.
- 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.
    - 서비스-DAO 구조
        - 예) 상품 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 CRUD 방식으로 구현해도 된다.
        - DAO와 데이터 중심의 밸류 객체를 이용해서 리뷰 기능을 구현해도 기능을 유지보수하는 데 큰 문제가 없다.
        - 도메인 기능이 서비스에 흩어지게 되지만, 도메인 기능 자체가 단순하면 서비스-DAO로 구성된 CRUD 방식을 사용해도 코드를 유지 보수하는 데 문제 되지 않는다.
    - CQRS 패턴
        - 두 방식을 혼합해서 사용하는 방식
        - **상태를 변경하는 명령 기능과 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴**이다.
        - 상태 변경과 관련된 기능은 **도메인 모델 기반으로 구현**하고, 조회 기능은 **서비스-DAO를 이용해서 구현**할 수 있다.
- 각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다.
    - JPA/하이버네이트, Netty 등
    - RDBMS, NoSQL 등
- 바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니다.
    - HTML 응답, JSON 응답 등
    - UI를 처리 하는 서버를 두고 UI 서버에서 바운디드 컨텍스트와 통신해서 사용자 요청을 처리하는 방식도 있다.
        - UI 서버는 각 바운디드 컨텍스트를 위한 **파사드 역할을 수행**한다.
        - 브라우저가 UI서버에 요청을 보내면 UI 서버는 카탈로그와 리뷰 바운디드 컨텍스트로부터 필요한 정보를 읽어와 조합한 뒤 브라우저에 응답을 제공한다.


## 9.4 바운디드 컨텍스트 간 통합
- 각각의 컨텍스트의 도메인 모델은 서로 다르다.
    - 예) 카탈로그 컨텍스트는 제품을 중심으로 도메인 모델을 구현, 추천 컨텍스트는 추천 연산을 위한 모델을 구현한다.
- 각각의 컨텍스트에서 데이터를 받아오려면 각 컨텍스트의 모델을 기반으로 하는 **도메인 서비스**를 이용해서 기능을 표현해야 한다.
    - 도메인 서비스를 구현한 클래스는 인프라스트럭처 영역에 위치한다.
    - **외부 시스템과의 연동을 처리하고 외부 시스템의 모델과 현재 도메인 모델간의 변환을 책임**진다.
- **바운디드 컨텍스트를 통합하는 방법**
    - **REST API**
        - 대표적인 두 바운디드 컨텍스트를 직접 통합하는 방법.
    - **메시지 큐**
      
      ![img.png](사진폴더/09/9.13%20메시지%20큐를%20이용한%20통합.png)
        - 대표적인 두 바운디드 컨텍스트를 간접적으로 통합하는 방법.
        - 이 방식은 **한쪽에서 메시지를 출판하고 다른 쪽에서 메시지를 구독하는 출판/구독 모델**을 따른다.
        - **비동기로 메시지를 처리**하기 때문에 카탈로그 바운디드 컨텍스트는 메시지를 큐에 추가한 뒤에 추천 바운디드 컨텍스트가 메시지를 처리할 때까지 기다리지 않고, 바로 이어서 자신의 처리를 계속한다.
        - 두 바운디드 컨텍스트가 **사용할 메시지의 데이터 구조**를 맞춰야 한다.
        - 큐를 누가 제공하느냐에 따라 데이터 구조가 결정된다.
            
            ![img.png](사진폴더/09/9.16%20출판,구독%20모델을%20이용한%20바운디드%20컨텍스트%20간%20연동.png)
            - 예) 카탈로그 시스템에서 큐를 제공한다면 큐에 담기는 내용은 카탈로그 도메인을 따른다.

- ✅ 참고 ✅
    - 마이크로서비스와 바운디드 컨텍스트
        - 각 바운디드 컨텍스트는 모델의 경계를 형성하는 데 바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트별로 모델이 분리된다.
        - 코드로 생각하면 마이크로서비스마다 프로젝트를 생성하므로 바운디드 컨텍스트마다 프로젝트를 만들게 된다.
        - 이것은 코드 수준에서 모델을 분리하여 두 바운디드 컨텍스트의 모델이 섞이지 않도록 해준다.
        - 별도 프로세스로 개발한 바운디드 컨텍스트는 독립적으로 배포하고 모니터링하며 확장되는데 이 역시 마이크로서비스가 갖는 특징이다.


## 9.5 바운디드 컨텍스트 간 관계
- 바운디드 컨텍스트는 **어떤 식으로든 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식을 관계**를 맺는다.
- 연결 방식 종류
    - **REST API**
        - 대표적인 연결 방식
        - API를 사용하는 바운디드 컨텍스트는 **API를 제공하는 바운디드 컨텍스트에 의존**하게 된다.
        - 단일 관계
            
            ![img.png](사진폴더/09/9.17%20고객,공급자%20관계를%20갖는%20바운디드%20컨텍스트.png)
            - **상류 컴포넌트**
                - **일종의 서비스 공급자 역할**을 한다.
                - 하류 컴포넌트가 사용할 수 있는 **통신 포로토콜을 정의하고 이를 공개**한다.
                    - 예) REST API, 프로토콜 버퍼 등
            - **하류 컴포넌트**
                - **서비스를 사용하는 고객 역할**을 한다.
            - 고객과 공급자 관계에 있는 두 팀은 **상호 협력이 필수적**이다.
        - 다중 관계

            ![img.png](사진폴더/09/9.18%20서비스를%20제공할%20하류%20컴포넌트가%20많다면%20각%20하류팀의%20요구사항을%20수용해서%20이를%20단일%20서비스로%20공개한다.png)
            - **공개 호스트 서비스**
                - 상류 팀의 고객인 하류 팀이 다수 존재하면 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고, 서비스 형태로 공개해서 서비스의 일관성을 유지하는 방법.
                    - 예) 검색 - 블로그, 카페, 게시판과 같은 서비스를 제공하는 포털은 각 서비스별로 검색 기능을 구현하기 보다는 **검색을 위한 전용 시스템을 구축하고, 검색 시스템과 각 서비스를 통합**한다.
                - 상류 팀은 각 하류 컴포넌트의 요구사항을 수용하는 단일 API를 만들어 이를 공개하고 각 하류 팀은 공개된 API를 사용해서 검색 기능을 구현한다.
        - **안티코럽션 계층**
            - 외부 시스템 도메인을 호출하는 서비스 클래스
            - 상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따르기 때문에, **하류 컴포넌트는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 보호해 주는 완충 지대**를 만들어야 한다.
    - **공유 커널**
        - 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우.
        - 장점 : 중복을 줄여준다.
        - 단점 : 한 팀에서 임의로 모델을 변경하면 다른 팀에서 영향을 받는다.
        - 공유 커널을 사용할 때의 장점보다 공유 커널로 인해 **개발이 지연되고 정체되는 문제**가 더 커지게 된다.
    - **독립 방식**
        - 두 바운디드 컨텍스트 간에 통합하지 않으므로 서로 독립적으로 모델을 발전시킨다.
        - 독립 방식에서 두 바운디드 컨텍스트 간의 통합은 수동으로 이루어진다.
        - 규모가 커질수록 수동 통합에는 한계가 있으므로 규모가 커지기 시작하면 두 바운디드 컨텍스트를 통합해야 한다.


## 9.6 컨텍스트 맵
![img.png](사진폴더/09/9.22%20바운디드%20컨텍스트%20간%20관계를%20표시한%20컨텍스트%20맵.png)
- 개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때를 방지하기 위해 **전체 비즈니스를 조망할 수 있는 지도**
- 각 바운디드 컨텍스트의 경계가 명확하게 드러나고 서로 어떤 관계를 맺고 있는지 알 수 있다.
- 컨텍스트 맵은 **시스템의 전체 구조를 보여준다.**
- 장점
    - 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 **도메인에 맞게 바운디드 컨텍스트를 조절**할 수 있다.
    - 사업의 핵심 도메인을 위해 **조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는 데 도움**을 준다.
- 컨텍스트 맵을 그리는 규칙이 없기 때문에, 단순하게 화이트보드나 파워포인트와 같은 도구를 이용해서 쉽게 그릴 수 있다.
- 시스템을 더 잘 이해하거나 시간이 지나면서 **컨텍스트 간 관계가 바꾸면 컨텍스트 맵도 함께 바뀐다.**