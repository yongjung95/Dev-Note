# 08장 애그리거트 트랜잭션 관리

## 8.1 애그리거트와 트랜잭션
![img.png](사진폴더/08/8.1%20한%20애그리거트를%20두%20사용자가%20동시에%20변경할%20때%20트랜잭션이%20필요하다.png)
- 트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.
  - 운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트지만 물리적으로 서로 다른 애그리거트 객체를 사용한다.
- 트랜잭션을 사용하더라도 일관성이 깨지는 문제가 발생할 수 있다.
  - 해결방안
    - 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.
    - 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.
    - **DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요**하다.
      - **선점 잠금과 비선점 잠금**


## 8.2 선점 잠금
![img.png](사진폴더/08/8.2%20선점%20잠금의%20동작%20방식.png)
- **먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리겉르르 수정하지 못하게 막는 방식**이다.
  - 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 **데이터 충돌 문제를 해소**할 수 있다.
- 선점 잠금은 보통 **DBMS가 제공하는 행단위 잠금을 사용해서 구현**한다.
  - 오라클을 비롯한 다수의 DBMS가 **for update와 같은 쿼리를 사용해서 특정 레코드에 한 커넥션만 접근할 수 있는 잠금장치를 제공**한다.
  - JPA EntityManager는 LockModeType을 인자로 받는 find() 메서드를 제공한다.
    - 예시) `Order order = enttiyManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE);`
    - JPA 프로바이더와 DBMS에 따라 잠금 모드 구현이 다르다.
      - 하이버네이트의 경우 `for update` 쿼리를 이용해서 선점 잠금을 구현한다.
  - 스프링 데이터 JPA는 **@Lock 애너테이션**을 사용해서 잠금 모드를 지정한다.
    ```java
      @Lock(LockModeType.PESSIMISTIC_WRITE)
      @Query("select m from Member m where m.id = :id")
      Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
    ```

### 8.2.1 선점 잠금과 교착 상태
- **선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교창 상태가 발생하지 않도록 주의**해야 한다.
  - 예시)
    - 스레드 1 : A 애그리거트에 대한 선점 잠금 구함
    - 스레드 2 : B 애그리거트에 대한 선점 잠금 구함
    - 스레드 1 : B 애그리거트에 대한 선점 잠금 시도
    - 스레드 2 : A 애그리거트에 대한 선점 잠금 시도
    - 두 스레드는 상대방 스레드가 먼저 선점한 잠금을 구할 수 없어 더 이상 다음 단계에 진행하지 못하게 되는 **교착 상태**에 빠진다.
- 선점 잠금에 따른 교착 상태는 **상대적으로 사용자 수가 많을 때 발생할 가능성이 높고**, **사용자수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가**한다.
  - **더 많은 스레드가 교착 상태에 빠질수록 시스템은 아무것도 할 수 없는 상태**가 된다
- 이런 문제가 발생하지 않도록 하려면 **잠금을 구할 때 최대 대기 시간을 지정**해야 한다.
  - **JPA에서는 선점 잠금을 시도할 때 최대 대기 시간을 지정하려면 힌트**를 사용한다.
    ```java
    Map<String, Object> hints = new HashMap<>();
    hints.put("javax.persistence.lock.timeout", 2000);
    Order order = enttiyManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE, hints);
    ```
    - **지정한 시간 이내에 잠금을 구하지 못하면 익셉션을 발생**시킨다.
    - **힌트를 사용할 때 주의할 점은 DBMS에 따라 힌트가 적용되지 않을 수도 있다는 것**이다.
  - **스프링 데이터 JPASMS `@QueryHints` 애너테이션을 사용해서 쿼리 힌트를 지정**할 수 있다.
    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints({
      @QueryHint(name = "javax.persistence.lock.timeout", value = "2000")
    })
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
    ```
- ⚠️주의⚠️
  - 선점 잠금을 사용하려면 사용하는 DBMS에 대해 JPA가 어떤 식으로 대기 시간을 처리하는지 반드시 확인해야 한다.


## 8.3 비선점 잠금
![img.png](사진폴더/08/8.5%20비선점%20잠금을%20이용한%20트랜잭션%20충돌%20방지.png)
- 선점 잠금이 강력해 보이긴 하지만 **선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다.**
- 비선점 잠금은 **동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식**이다.
- 비선점 잠금은 구현하려면 **애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가**해야 한다.
  ```sql
  UPDATE aggtable SET version = version + 1, colx = ?, coly = ? WHERE aggid = ? and version = 현재버전
  ```
  - 이 쿼리는 수정할 애그리거트와 매핑되는 테이블의 버전 값이 현재 애그리거트의 버전과 동일한 경우에만 데이터를 수정한다.
- JPA는 버전을 이용한 비선점 잠금 기능을 지원한다.
  - 사용할 필드에 `@Version 애너테이션을 붙이고 매핑되는 테이블에 버전을 저장할 칼럼을 추가하면 된다.
  - 엔티티가 변경되어 UPDATE 쿼리를 실행할 때 `@Version`에 명시한 필드를 이용해서 **비선점 잠금 쿼리를 실행**한다.
- 응용 서비스는 버전에 대해 알 필요가 없다.
  - **리포지터리에서 필요한 애그리거트를 구하고 알맞은 기능만 실행**하면 된다.
  - 기능 실행 과정에서 애그리거트 데이터가 변경되면 **JPA는 트랜잭션 종료 시점에 비선점 잠금을 위한 쿼리를 실행**한다.
  - 비선점 잠금을 위한 **쿼리를 실행할 때 쿼리 실행 결과로 수정된 행의 개수가 0이면 이미 누군가 앞서 데이터를 수정한 것**이다.
  - 이는 트랜잭션이 충돌한 것이므로 트랜잭션 종료 시점에 **익셉션이 발생**한다.
  - 표현 영역 코드는 **익셉션이 발생했는지에 따라 트랜잭션 충돌이 일어났는지 확인**할 수 있다.

![img.png](사진폴더/08/8.6%20비선점%20잠금을%20이용한%20트랜잭션%20충돌%20방지를%20여러%20트랜잭션으로%20확장.png)
- **사용자가 전송한 버전과 애그리거트 버전이 동일한 경우에만 애그리거트 수정 기능을 수행하도록 함으로써 트랜잭션 충돌 문제를 해소**할 수 있다.
- **응용 서비스에 전달할 요청 데이터는 사용자가 전송한 버전 값을 포함**한다.
  - 예) 배송 상태 변경을 처리하는 응용 서비스가 **전달받는 데이터는 주문번호와 함게 해당 주문을 조회한 시점의 버전 값을 포함**해야 한다.
  - 응용 서비스는 **전달 받은 버전 값을 이용해서 애그리거트 버전과 일치하는지 확인하고, 일치하는 경우에만 기능을 수행**한다.
- 표현 계층은 **버전 충돌 익셉션이 발생하면 버전 충돌을 사용자에게 알려 사용자가 알맞은 후속 처리**를 할 수 있도록 한다.
  - 스프링 프레임워크가 발생하는 익셉션과 응용 서비스 코드에서 발생하는 익셉션을 동시에 처리하면 이점
    - 트랜잭션 충돌이 발생한 시점을 명확하게 구분
    - 스프링 프레임워크가 발생시키는 익셉션은 **누군가 거의 동시에 애그리거트를 수정했다는 것을 의미**
    - 응용 서비스 코드에서 발생시키는 익셉션은 **누군가 애그리거트를 수정했다는 것을 의미**

### 8.3.1 강제 버전 증가
- 애그리거트에 애그리거트 루트 외에 다른 엔티티가 존재하는데 기능 실행 도중 **루트가 아닌 다른 엔티티의 값만 변경 시에는 JPA는 루트 엔티티의 버전 값을 증가시키지 않는다.**
  - JPA의 이런 특징은 **애그리거트 관점에서 보면 문제**가 된다.
- **애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버전 값이 증가해야 비선점 잠금이 올바르게 동작**한다.
  - JPA는 **엔티티를 구할 때 강제로 버전 값을 증가시키는 잠금 모드를 지원**한다.
    - **해당 엔티티의 상태가 변경되었는지에 상관없이 트랜잭션 종료 시점에 버전 값 증가 처리**를 한다.
  - 스프링 데이터 JPA는 `@Lock` 애너테이션을 이용해서 지정하면 된다.


## 8.4 오프라인 선점 잠금
![img.png](사진폴더/08/8.8%20오프라인%20선점%20잠금%20방식.png)
- 단일 트랜잭션에서 동시 변경을 막는 선점 잠금방식과 달리 오프라인 선점 잠금은 **여러 트랜잭션에 걸쳐 동시 변경을 막는다.**
  - **첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제**한다.
  - **잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.**
- 오프라인 선점 방식은 **잠금 유효 시간**을 가져야 한다.
  - **잠금을 해제하지 않으면, 다른 사용자는 영원히 잠금을 구할 수 없는 상황이 발생하기 때문.**
  - **유효 시간이 지나면 자동으로 잠금을 해제해서 다른 사용자가 잠금을 일정 시간 후에 다시 구할 수 있도록 해야 한다.**

### 8.4.1 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스
```java
public interface LockManager {
    LockId tryLock(String type, String id) throws LockException;

    void checkLock(LockId lockId) throws LockExceptions;

    void releaseLock(LockId lockId) throws LockExceptions;

    void extendLockExpiration(LockId lockId, long inc) throws LockExceptions;
}
```
- 오프라인 선점 잠금은 크게 **잠금 선점 시도, 잠금 확인, 잠금 해제, 잠금 유효시간 연장의 네 가지 기능이 필요**하다.

### 8.4.2 DB를 이용한 LockManager 구현
```sql
create table locks (
  'type' varchar(255),
  id varchar(255),
  lockid varchar(255),
  expiration_time datetime,
  primary key ('type', id)
) character set utf8;

create unique index locks_idx ON locks (lockid);
```
- 잠금 정보를 저장할 테이블과 인덱스를 같이 생성한다.
- type과 id 칼럼을 주요키로 지정해서 **동시에 두 사용자가 특정 타입 데이터에 대한 잠금을 구하는 것을 방지**한다.
- 각 잠금마다 새로운 LockId를 사용하므로 lockid 필드를 유니크 인덱스로 설정.
