# 6장 메시지와 인터페이스
## 개요
- 훌륭한 객체지향 코드를 얻기 위해서는 `클래스가 아니라 객체를 지향`해야 한다.
  - 좀 더 정확하게 말해서 `협력 안에서 객체가 수행하는 책임에 초점`을 맞춰야 한다.
  - 여기서 중요한 것은 `책임이 객체가 수신할 수 있는 메시지의 기반`이 된다는 것이다.
- 객체지향 애플리케이션의 가장 중요한 재료는 `클래스가 아니라 객체들이 주고받는 메시지`다.
- 객체가 수신하는 메시지들이 `객체의 퍼블릭 인터페이스를 구성`한다.
  - 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 `책임 주도 설계 방법을 따르는 것만으로는 부족`하다.
  - `도움이 되는 설계 원칙과 기법을 익히고 적용`해야 한다.


## 01. 협력과 메시지
### 클라이언트-서버 모델
- 메시지는 `객체 사이의 협력을 가능하게 하는 매개체`다.
  - 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 `메시지를 전송하는 것`뿐이다.
- 클라이언트-서버
  - 협력 안에서 `메시지를 전송하는 객체를 클라이언트`, `메시지를 수신하는 객체를 서버`라고 부른다.
  - 협력은 `클라이언트가 서버의 서버스를 요청하는 단방향 상호작용`이다.
- 객체는 협력에 참여하는 동안 `클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적`이다.
  - 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다.
    - `객체가 수신하는 메시지의 집합`
    - `외부의 객체에게 전송하는 메시지의 집합`
  - 객체가 수신하는 메시지의 집합에만 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 `외부에 전송하는 메시지의 집합도 함께 고려`하는 것이 바람직하다.
- 요점
  - 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 `다른 객체와 협력해야 한다는 것`이다.
  - 그리고 `두 객체 사이의 협력을 가능하게 해주는 매게체가 바로 메시지`라는 것이다.

### 메시지와 메시지 전송
- 메시지는 `객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단`이다.
- 메시지는 `오퍼레이션명`과 `인자`로 구성되며 메시지 전송은 여기에 `메시지 수신자`를 추가한 것이다.
  - 따라서 메시지 전송은 `메시지 수신자, 오퍼레이션명, 인자`의 조합이다.

### 메시지와 메서드
- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다.
- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 `메서드`라고 부른다.
  - 중요한 것은 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 `객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 것`이다.
  - 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 `컴파일 시점과 실행 시점의 의미가 달라`질 수 있다.
- 객체지향이 메시지 전송과 메서드 호출을 명확하게 구분한다는 사실이 여러분을 모호함의 덫으로 밀어 넣을 수도 있다.
  - `메시지 전송을 코드 상에 표기하는 시점에는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다.`
    - 실행 시점에 실제로 실행디는 코드는 `메시지를 수신하는 객체의 타입에 따라 달라지기 때문`이다.
- 메시지와 메서드의 구분은 `메시지 전송자와 메시지 수신자가 느슨하게 결합`될 수 있게 한다.
  - `수신자가 어떤 클래스의 인스턴스인지, 어떤 방식으로 요청을 처리하는지 모르더라도 원활한 협력`이 가능하다.
  - 메시지 수신자는 `메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권`을 가진다.
- 메시지 전송자와 메시지 수신자는 `서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 얇고 가는 끈으로 통해 연결`된다.
  - 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 `두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성`할 수 있게 만든다.

### 퍼블릭 인터페이스와 오퍼레이션
- 퍼블릭 인터페이스
  - 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합.
- 오퍼레이션
  - 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지.
  - 오페레이션은 `수행 가능한 어떤 행동에 대한 추상화`다.
- 메서드
  - 메시지를 수신했을 때 실제로 실행되는 코드.
  
### 시그니처
- 시그니처
  - 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합친 것.
- 일반적으로 메시지를 수신하면 `오퍼레이션의 시그니처와 동일한 메서드가 실행`된다.
- 다형성의 축복을 받기 위해서는 `하나의 오퍼레이션에 대해 다양한 메서드를 구현`해야 한다.
  - 따라서 오퍼레이션의 관점에서 다형성이란 `동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것`이라고 정의할 수 있다.

### 용어 정리
- 메시지
  - 객체가 다른 객체와 협려갛기 위해 사용하는 의사소통 메커니즘.
- 오퍼레이션
  - 객체가 다른 객체에게 제공하는 추상적인 서비스다.
  - 메시지가 전송자와 수신자 사이의 협력관계를 강조하는 데 비해 오퍼레이션은 `메시지를 수신하는 객체의 인터페이스를 강조`한다.
  - 메시지 수신이란 `메시지에 대응되는 객체의 오퍼레이션을 호출`하는 것을 의미한다.
- 메서드
  - 메시지에 응답하기 위해 실행되는 코드 블록을 메서드라고 부른다.
  - `메서드는 오퍼레이션의 구현`이다.
  - 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다.
  - 오퍼레이션과 메서드의 구분은 다형성의 개념과 연결된다.
- 퍼블릭 인터페이스
  - 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음.
  - 클래스의 퍼블릭 메서드들의 집합이나 메시지의 집합을 가리키는 데 사용된다.
  - 객체를 설계할 때 가장 중요한 것은 `퍼블릭 인터페이스를 설계`하는 것이다.
- 시그니처
  - 오퍼레이션이나 메서드의 명세를 나타낸 것으로, 이름과 인자의 목록을 포함한다.

### 정리
- 객체가 수신할 수 있는 `메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정`한다는 것이다.
- 객체의 퍼블릭 인터페이스가 `객체의 품질을 결정`하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.


## 02. 인터페이스와 설계 품질
- 좋은 인터페이스는 `최소한의 인터페이스와 추상적인 인터페이스`라는 조건을 만족해야 한다.
  - 최소한의 인터페이스는 `꼭 필요한 오퍼레이션만을 인터페이스에 포함`한다.
  - 추상적인 인터페이스는 `어떻게 수행하는지가 아니라 무엇을 하는지를 표현`한다.
- 최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 `책임 주도 설계 방법`을 따르는 것.
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
  - 디미터 법칙
  - 묻지 말고 시켜라
  - 의도를 드러내는 인터페이스
  - 명령-쿼리 분리

### 디미터 법칙
- 협력하는 객체의 내부 구조에 대한 결합으로 발생하는 설계 문제를 해결하기 위해 제안된 원칙
  - `객체의 내부 구조에 강하게 결합되지 않도록 협력 경록을 제한`하라는 것이다.
- 디미터 법칙을 따르기 위해서는 `클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송`하도록 프로그래밍해야 한다.
  - this 객체
  - 메서드의 매개변수
  - this의 속성
  - this의 속성인 컬렉션의 요소
  - 메서드 내에서 생성된 지역 객체
- 디미터 법칙을 따르면 `부끄럼타는 코드`를 작성할 수 있다.
  - 부끄럼타는 코드란 `불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드`를 말한다.
  - `메시지의 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합`되지 않는다.
  - 따라서 `클라이언트와 서버 사이에 낮은 결합도를 유지`할 수 있다.
- 디미터 법칙은 `객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조`한다.
  - 정보를 처리하는 데 필요한 책임을 정보을 알고 있는 객체에게 할당하기 때문에 `응집도가 높은 객체`가 만들어진다.
- 디미터 법칙은 객체의 내부 구조를 묻는 메시지가 아니라 `수신자에게 무언가를 시키는 메시지가 더 좋은 메시지`라고 속삭인다.

### 묻지 말고 시켜라
- 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 `원하는 것을 시키는 스타일의 메시지 작성을 장려`하는 원칙을 가리키는 용어다.
- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.
  - 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 `객체의 캡슐화를 위반`한다.
- 묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.
  - 객체지향의 기본은 `함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합`하는 것이다.
  - 묻지 말고 시켜라 원칙을 따르면 `객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치`시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.
  - 묻지 말고 시켜라 원칙을 따르도록 메시지를 결정하다 보면 자연스럽게 `정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스`를 얻을 확률이 높아진다.
- 묻지 말고 시켜라 원칙과 디미터 법칙은 `훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공`한다.
- 상태를 묻는 오퍼레이션을 `행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상`시켜라

### 의도를 드러내는 인터페이스
- 메서드를 명명하는 두 가지 방법
  - 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는 것.
  - '어떻게'가 아니라 '무엇을'을 하는지를 드러내는 것.
    - 객체가 `협력 안에서 수행해야 하는 책임에 관해 고민`해야 한다.
    - 이것은 `외부의 객체가 메시지를 전송하는 목적을 먼저 생각`하도록 만들며, 결과적으로 `협력하는 클라이언트의 의도에 부합하도록 메서드의 이름`을 짓게 된다.
    - 클라이언트의 관점에서 `동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성`이 커진다.
      - `동일한 타입으로 선언하기 위해 인터페이스를 실체화`하면 클라이언트 입장에서 두 메서드를 `동일한 방식으로 사용`할 수 있게 된다.
      - 그 결과, `다양한 타입의 객체가 참여할 수 있는 유연한 협력`을 얻게 되는 것이다.
    - 이 패턴을 `의도를 드러내는 선택자`라고 부른다.
- `객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도`를 드러내야 한다.
  - 이것이 `이해하기 쉽고 유연한 동시에 협력적인 객체를 만드는 가장 기본적인 요구사항`이다.

### 함께 모으기
- 근본적으로 디미터 법칙을 위반하는 설계는 `인터페이스와 구현의 분리 원칙을 위반`한다.
  - 기억해야 할 점은 `객체의 내부 구조는 구현`에 해당한다는 것이다.
  - 디미터 법칙을 위반한다는 것은 `클라이언트에게 구현을 노출한다는 것을 의미`하며, 그 결과 `작은 요구사항 변경에도 쉽게 무너지는 불안정한 코드`를 얻게 된다.
- 일반적으로 프로그램에 노출되는 `객체 사이의 관계가 많아질수록 결합도가 높아지기 때문에 프로그램은 불안정`해진다.
  - `객체의 구조는 다양한 요구사항에 의해 쉽게 변경`되기 쉽기 때문에 `디미터 법칙을 위반한 설계는 요구사항 변경에 취약`해진다.
- 디미터 법칙을 위반한 코드는 `사용하기도 어렵다.`
- 디미터 법칙을 위반한 코드를 수정하는 일반적인 방법은?
  - 묻지 말고 시켜라
    - 디미터 법칙과 묻지 말고 시켜라 스타일을 따르면 `자연스럽게 자율적인 객체로 구성된 유연한 협력`을 얻게 된다.
    - 구현이 객체의 퍼블릭 인터페이스에 노출되지 않기 때문에 `객체 사이의 결합도는 낮아진다.`
    - 책임이 잘못된 곳에 할당될 가능성이 낮아지기 때문에 `객체의 응집도 역시 높아진다.`
    - 일단 디미터 법칙과 묻지 말고 시켜라 스타일을 따르는 인터페이스를 얻었다면 `인터페이스가 클라이언트의 의도를 올바르게 반영했는지를 확인`해야 한다.
  - 인터페이스에 의도를 드러내자
    - `오퍼레이션의 이름은 협력이라는 문맥을 반영`해야 한다.
    - 오퍼레이션은 `클라이언트가 객체에게 무엇을 원하는지를 표현`해야 한다.
      - 다시 말해 `객체 자신이 아닌 클라이언트의 의도를 표현`하는 이름을 가져야 한다.

### 정리
- 디미터 법칙은 `객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한`한다.
- 묻지 말고 시켜라 원칙은 `디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시`한다.
- 의도를 드러내는 인터페이스 원칙은 `객체의 펍르릭 인터페이스에 어떤 이름을 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션`할 수 있게 해준다.
- 우리는 `결합도가 낮으면서도 의도를 명확히 드러내는 간결한 협력`을 원한다.
  - 디미터 법칙과 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스가 우릴 도울 것이다.


## 03. 원칙의 함정
- 디미터 법칙과 묻지 말고 시켜라 스타일은 객체의 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있는 훌륭한 설계 원칙이다.
  - `하지만 절대적인 법칙은 아니다.`
  - `소프트웨어 설계에 법칙이란 존재하지 않는다.`
  - 법칙에는 예외가 없지만 `원칙에는 예외가 넘쳐난다.`
- `설계가 트레이드 오프의 산물`

### 디미터 법칙은 하나의 도트(. / 기차충돌코드)를 강제하는 규칙이 아니다.
- `디미터 법칙은 결합도와 관련`된 것이며, 이 결합도가 문제가 되는 것은 `객체의 내부 구조가 외부로 노출되는 경우로 한정`된다.
- 하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다.
  - 기차 충돌처럼 보이는 코드라도 `객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수`한 것이다.

### 결합도와 응집도의 충돌
- 안타깝게도 묻지 말고 시켜라와 디미터 법칙을 준수하는 것이 `항상 긍정적인 결과만 귀결`되는 것은 아니다.
  - 모든 상황에서 맹목적으로 위임 메서드를 추가하면 `같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존`하게 된다.
  - 결과적으로 `객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.`
- 클래스는 하나의 변경 원인만을 가져야 한다.
  - 서로 상관 없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으면 작은 변경에도 쉽게 무너질 수 있다.
  - 따라서 디미터 법칙과 묻지 말고 시켜라 원칙을 무작정 따르면 `애플리케이션은 응집도가 낮은 객체`로 넘쳐날 것이다.
- `객체에게 시키는 것이 항상 가능한 것은 아니다.`
  - `가끔씩은 물어야 한다.`


## 04. 명령-쿼리 분리 원칙
- 명령-쿼리 분리 원칙은 `퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공`한다.
- 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 `루틴`이라고 한다.
  - 루틴은 다시 `프로시저`와 `함수`로 구분할 수 있다.
  - 프로시저
    - 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
  - 함수
    - 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
- `명령`과 `쿼리`는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또다른 이름이다.
  - `객체의 상태를 수정하는 오퍼레이션`을 명령
  - `객체와 관련된 정보를 반환하는 오퍼레이션`을 쿼리
  - 개념적으로 `명령은 프로시저와 동일하고 쿼리는 함수와 동일`하다.
- 명령와 쿼리를 분리하기 위한 규칙
  - `객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.`
  - `객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.`
- `명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워`질 수 있다.
  - 겉으로 보기에는 쿼리처럼 보이지만 내부적으로 부수효과를 가지는 메서드는 `이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향`이 있다.
  - 가장 깔끔한 해결책은 `명령과 쿼리를 명확하게 분리`하는 것이다.
- `퍼블릭 인터페이스를 설계할 때 부수효과를 가지는 대신 값을 반환하지 않는 명령과, 부수효과를 가지지 않는 대신 값을 반환하는 쿼리를 분리`하기 바란다.
  - 그 결과, 코드는 `예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월`해질 것이다.

### 명령-쿼리 분리와 참조 투명성
- 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 `참조 투명성`의 장점을 제한적이나마 누릴 수 있게 된다.
  - 참조 투명성이란 "어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성"을 의미한다.
  - 참조 투명성이라는 특성을 잘 활용하면 `버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성`할 수 있다.
  - 예) f(1) + f(1) = 6, f(1) * 2 = 6 이면 f(1) = 3
- 컴퓨터의 셰계와 수학의 세계를 나누는 가장 큰 특징은 `부수효과의 존재 유무`다.
  - 부수효과를 이야기할 때 빠질 수 없는 것이 바로 `참조 투명성`이다.
  - 참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산 할 수 있게 해준다.
  - 어떤 값이 변하지 않는 성질을 `불변성`이라고 부른다.
    - 사실 어떤 값이 불변한다는 말은 `부수효과가 발생하지 않는다`는 말과 동일하다.
- 참조 투명성을 만족하는 식이 주는 장점
  - `모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산`할 수 있다.
  - `모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.`
- 객체지향 패러다임이 `객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외`에 가깝다.
  - 객체지향의 세상에 발을 내딛는 순간 견고하다고 생각했던 바닥에 심각한 균열이 생기기 시작한다는 것을 알게 된다.
- 하지만 `명령-쿼리 분리 원칙을 사용하면 이 균열을 조금이나마 줄일 수 있다.`
  - `부수효과를 가지는 명령으로 부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함`으로써 `제한적이나마 참조 투명성의 혜택`을 누릴 수 있게 된다.

### 책임에 초점을 맞춰라
- 디미터 법칙을 준수하고 묻지 말고 시켜라 스타일을 따르면서도 의도를 드러내는 인터페이스를 설계하는 아주 쉬운 방법이 있다.
  - `메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택`하는 것이다.
- 명령과 쿼리를 분리하고 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적을 드러낼 수 있는 방법이 있다.
  - `객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연`하게 만드는 것이다.
- 이 모든 방식의 중심에는 `객체가 수행할 책임이 위치`한다.
- 메시지를 먼저 선택하는 방식이 디미터 법칙, 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스, 명령-쿼리 분릭 원칙에 미치는 긍정적인 영향
  - 디미터 법칙
    - 협력이라는 컨텍스트 안에서 `객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도`를 낮출 수 있다.
    - 수신할 객체를 알지 못한 상태에서 `메시지를 먼저 선택`하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.
    - 따라서 `메시지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화`할 수 있다.
  - 묻지 말고 시켜라
    - 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 `협력을 구조화`하게 된다.
    - 클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.
  - 의도를 드러내는 인터페이스
    - 메시지를 먼저 선택해야 한다는 것은 `메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다`는 것이다.
    - 당연히 그 이름에는 `클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날` 수 밖에 없다.
  - 명령-쿼리 분릭 원칙
    - 메시지를 먼저 선택한다는 것은 `협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미`한다.
    - 객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다.
    - 따라서 `예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리`하게 될 것이다.
- 훌륭한 메시지를 얻기 위한 출발점은 `책임 주도 설계 원칙을 따르는 것`이다.
  - 우리에게 중요한 것은 협력에 적합한 객체가 아니라 `협력에 적합한 메시지`다.
  - 책임 주도 설계 방법에 따라 `메시지가 객체를 결정`하게 하라.
  - 그러면 여러분의 설계가 아름답고 깔끔해지며 심지어 우아해진다는 사실을 실감하게 될 것이다.