# 15장 디자인 패턴과 프레임워크
- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 `디자인 패턴`이라고 부른다.
  - 디자인 패턴의 목적은 `설계를 재사용하는 것`이다.
  - 디자인 패턴은 `다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음`이다.
  - 일단 디자인 패턴을 익히고 나면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들의 협력 방식을 순간적으로 떠올릴 수 있게 된다.
- `프레임워크`는 `설계와 코드를 함께 재사용하기 위한 것`이다.
  - 프레임워크는 `애플리케이션의 아키텍처를 구현 코드의 형태로 제공`한다.
  - 프레임워크가 제공하는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있다.
  - 프레임워크는 각 애플리케이션 요구에 따라 적절하게 커스터마이징할 수 있는 확장 포인트를 제공한다.
- 디자인 패턴과 프레임워크 모두 `일관성 있는 협력과 관련`이 있다.
  - 디자인 패턴은 `특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공`한다.
  - 프레임워크는 `특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공`한다.
  - `디자인 패텀이 협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음`이라면, `프레임워크는 일관성 있는 협력을 제공하는 확장 가능한 코드`라고 할 수 있다.
  - 결론적으로 `디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법`이다.


## 01. 디자인 패턴과 설계 재사용
### 소프트웨어 패턴
- 패턴이라는 거대한 숲 속에서 길을 잃지 않기 위해서는 `패턴의 정의보다는 패턴이라는 용어 자체가 풍기는 미묘한 뉘앙스를 이해`하는 것이 중요하다.
- 패턴의 핵심적인 특징
  - `패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다`
  - `패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다`
  - `패턴은 추상적인 원칙과 실제 코드 작성 사이의 간득을 메워주며 실질적인 코드 작성을 돕는다`
  - `패턴의 요점은 패턴이 실무에서 탄생했다는 점이다`
- 패턴은 한 컨텍스트에서 유용한 동시에 `다른 컨텍스트에서도 유용한 '아이디어'`다.
- 패턴이 지닌 가장 큰 가치는 `경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달`할 수 있다는 점이다.
  - 패턴은 `경험의 산물`이다.
  - 따라서 실무 경험이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.
- 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 `패턴의 '이름'`이다.
  - 패턴의 이름은 `커뮤니티가 공유할 수 있는 중요한 어휘집을 제공`한다.
  - 패턴의 이름은 `높은 수준의 대화를 가능하게 하는 원천`이다.
- 마틴 파울러가 언급한 것처럼 패턴의 범위가 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아니다.
  - 다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 `반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상`이 될 수 있다.
- 패턴은 홀로 존재하지 않는다.
  - 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 `더 작은 패턴에 의해 서술될 수 있으며, 패턴들을 포함하는 더 큰 패턴 내에 통합`될 수 있다.
  - 연관된 패턴들의 집합들이 모여 하나의 `패턴 언어`를 구성한다.
    - 패턴 언어는 연관된 패턴 카테고리뿐만 아니라 `패턴의 생성 규칙과 함께 패턴 언어에 속한 다른 패턴과의 관계 및 협력 규칙을 포함`한다.
  
### 패턴 분류
- 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 `아키텍처 패턴`, `분석 패턴`, `디자인 패턴`, `이디엄`의 4가지로 분류하는 것이다.
- `디자인 패턴`
  - 특정 정황 내에서 `일반적인 설계 문제를 해결하며, 협력하는 컴포넌트 사이에서 반복적으로 발생하는 구조를 서술`한다.
  - 디자인 패턴은 중간 규모의 패턴으로, 특정한 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
- `아키텍처 패턴`
  - 소프트웨어의 전체적인 구조를 결정하기 위해 사용한다.
  - `미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함`한다.
  - 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며, 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
- `이디엄`
  - 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로, 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
  - 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.
- `분석 패턴`
  - `도메인 내의 개념적인 문제를 해결하는 데 초점`을 맞춘다.
  - 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
  - `단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용`할 수도 있다.

### 패턴과 책임-주도 설계
- 객체지향 설계에서 가장 중요한 일은 `올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력관계를 구축`하는 일이다.
  - 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들의 `트레이드오프를 통해 결정`된다.
  - 가끔씩 책임과 협력을 결정하는 작업이 손쉽게 진행될 때도 있지만 대부분의 경우에는 `훌륭한 품질의 설계를 얻기 위해 많은 시간과 노력`을 들여야만 한다.
- 패턴은 `공통적으로 사용할 수 있는 역할, 책임, 협력의 템플릿`이다.
  - 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.
  - 예)
    - STRATEGY 패턴은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다.
    - BRIDGE 패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합을 ㅗ분해함으로써 설계를 확장 가능하게 만든다.
    - OBSERVER 패턴은 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.
  - 중요한 것은 `패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실`이다.
    - 특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 `책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성`할 수 있다.
  - 패턴의 구성 요소는 `클래스가 아니라 '역할'`이다.
    - 패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 `패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시`한다.
    - 역할은 `동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시`하기 때문에 하나의 객체가 세 가지 역할 모두 수행하더라도 문제가 없다.
    - 반대로 `다수의 클래스가 동일한 역할을 구현`할 수도 있다.
- 디자인 패턴의 구성요소가 클래스와 메서드가 아니라 `역할과 책임이라는 사실을 이해하는 것이 중요`하다.
  - 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 `역할, 책임, 협력의 관점에서 유사성을 공유`한다는 것이지 특정한 구현 방식을 강제하는 것은 아니라는 점을 이해하는 것 역시 중요하다.
  - 디자인 패턴은 `단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.`
- 패턴을 적용하기 위해서는 패턴에서 제시하는 구조를 그대로 표현하는 것이 아니라 `패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야 한다는 것을 의미`한다.

### 캡슐화와 디자인 패턴
- 몇 가지 이례적인 경우를 제외하면 널리 알려진 대부분의 `디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적`으로 한다.
  - 따라서 각 디자인 패턴은 `특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의`하고 있다.
- 물론 변경을 캡슐화하는 방법이 `합성만 있는 것은 아니다.`
  - `상속을 이용`할 수도 있다.
- 추상 클래스나 인터페이스를 사용해 변경을 캡슐화하는 합성과 달리 상속을 사용할 경우에는 `추상 메서드를 이용해 변경을 캡슐화`해야 한다.
- 대부분의 디자인 패턴의 목적은 `특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유`하는 것이다.
  - 디자인 패턴에서 중요한 것은 `디자인 패턴의 구현 방법이나 구조가 아니다.`
  - `어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요`하다.
  - 그리고 `각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해`하는 것이 더 중요하다.

### 패턴은 출발점이다.
- 많은 전문가들은 널리 요구되는 유연성이나 공통적으로 발견되는 특정한 설계 이슈를 해결하기 위해 적절한 디자인 패턴을 이용해 설계를 시작한다.
  - 그러나 패턴은 `설계의 목표가 돼서는 안 된다.`
  - 패턴은 `단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과`하다.
  - 디자인 패턴이 `현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정`하라.
- 해결하려는 문제가 아니라 패턴이 제시하는 구조를 맹목적으로 따르는 것은 `불필요하게 복잡하고, 난해하며, 유지보수하기 어려운 시스템을 낳는다.`
  - 따라서 부적절한 상황에서 부적절하게 사용된 패턴으로 인해 `소프트웨어의 엔트로피를 증가하는 부작용을 낳기 쉽다.`
  - 패턴을 남용하지 않기 위해서는 `다양한 트레이드오프 관계 속에서 패턴을 적용하고 사용해 본 경험`이 필요하다.
- 전문가는 다양한 실무 경험을 통해 어떤 컨텍스트에서 어떤 패턴을 적용해야 하는지, 그리고 이보다 더 중요한 것으로 `어떤 패턴을 적용해서는 안 되는지에 대한 감각을 익히고 있다는 점`이다.
- 타당한 이유 없이 패턴을 적용하면 패턴에 `익숙한 사람들의 경우에는 설계의 의도를 이해하지 못하게 되고`, `패턴을 알지 못하는 사람들은 불필요하게 복잡한 설계를 따라가느라 시간을 낭비`하게 된다.
- 정당한 이유 없이 사용된 모든 패턴은 `설계를 복잡하게 만드는 장애물`이다.
  - 패턴은 `복잡성의 가치가 단순성을 넘어설 때만 정당화`돼야 한다.
  - 패턴을 적용할 때는 `항상 설계를 좀 더 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민`해야 하고, 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야 한다.
- 조슈아 케리에브스키는 패턴을 가장 효과적으로 적용하는 방법은 `패턴을 지향하거나 패턴을 목표로 리팩터링하는 것`이라고 이야기한다.
  - 그는 패턴이 적용된 최종 결과를 이해하는 것보다는 `패턴을 목표로 리팩터링하는 이유를 이해하는 것이 훨씬 가치` 있으며, `훌륭한 소프트웨어 설계가 발전해 온 과정을 공부하는 것이 훌륭한 설계 자체를 공부하는 것보다 훨씬 중요`하다고 이야기 한다.
- `패턴은 출발점`이다.
  - 패턴은 공통적인 문제에 적절한 해법을 제공하지만 `공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수도 있다.`
  - 문제를 분석하고 창의력을 발휘함으로써 `패턴을 현재의 문제에 적합하도록 적절하게 수정`하라.
  - 비록 패턴이 현재의 문제에 딱 들어맞지 않는다고 해도 `참조할 수 있는 모범적인 역할과 책임의 집합을 알고 있는 것은 큰 도움`이 될 것이다.


## 프레임워크와 코드 재사용
### 코드 재사용 vs 설계 재사용
- 재사용 관점에서 설계 재사용보다 더 좋은 방법은 `코드 재사용`이다.
- 가장 이상적인 형태의 재사용 방법은 `설계 재사용과 코드 재사용을 적절한 수준으로 조합`하는 것이다.
- `프레임워크`란
  - `추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계`, 또는 `애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격`을 의미한다.
  - 첫 번째 정의가 `프레임워크의 구조적인 측면에 초점`을 맞추고 있다면 두 번째 정의는 `코드와 설계의 재사용`이라는 프레임워크의 사용 목적에 초점을 맞춘다.
- 프레임워크는 `코드를 재사용함으로써 설계 아이디어를 재사용`한다.
  - 프레임워크는 `애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함`한다.
  - 또한 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 `추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공`한다.
  
### 상위 정책과 하위 정책으로 패키지 분리하기
- 프레임워크의 핵심은 `추상 클래스나 인터페이스와 같은 추상화`라고 할 수 있다.
- `추상 클래스와 인터페이스가 일관성 있는 협력을 만드는 핵심 재료`라는 것을 기억하라.
  - 협력을 일관성있고 유연하게 만들기 위해서는 `추상화를 이용해 변경을 캡슐화`해야 한다.
  - 그리고 협력을 구현하는 코드 안의 의존성은 `가급적이면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성`해야 한다.
- 요점은 `상위 정책이 세부 사항보다 더 다양한 상황에서 재사용`될 수 있어야 한다는 것이다.
  - 하지만 상위 정책이 세부 사항에 의존하게 되면 상위 정책이 필요한 모든 경우에 세부 사항도 항상 함께 존재해야 하기 때문에 `상위 정책의 재사용성이 낮아진다.`
  - 이 문제를 해결할 수 있는 가장 좋은 방법은 `의존성 역전 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존`하게 만드는 것이다.
- 의존성 역전 원칙의 관점에서 `세부 사항은 '변경'을 의미`한다.
- 프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 `변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 '배포 단위'로 분리`해야 한다.
  - 이를 위한 첫걸음은 `변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리`하는 것이다.
- 중요한 것은 `패키지 사이의 의존성 방향`이다.
  - 의존성 역전 원리에 따라 `추상화에만 의존하도록 의존성의 방향을 조정하고 추상화를 경계로 패키지를 분리`했기 때문에 `세부 사항을 구현한 패키지는 항상 상위 정책을 구현할 패키지에 의존`해야 한다.
- 상위 정책을 구현하고 있는 패키지가 충분히 안정적이고 성숙했다면 `하위 정책 패키지로부터 완벽히 분리해서 별도의 배포 단위`로 만들 수 있다.
  - 상위 정책 패키지와 하위 정책 패키지를 물리적으로 완전히 분리하고 나면 `상위 정책 패키지를 여러 애플리케이션에서 재사용할 수 있는 기반이 마련`된 것이다.
  - 다시 말해 `재사용 가능한 로직을 구현한 프레임워크가 만들어진 것`이다.
- 프레임워크는 `여러 애플리케이션에 걸쳐 일관성 있는 협력을 구현`할 수 있게 해준다.
  - 그리고 일관성 있는 협력이 제공하는 다양한 장점들은 `프레임워크에 대해서도 여전히 적용`된다.
  - 우리는 동일한 프레임워크를 사용하는 여러 애플리케이션에 걸쳐 `일관성 있게 코드를 설계하고 구현`할 수 있다.
  - 동일한 프레임워크를 사용하는 애플리케이션은 `구현 방식에 일관성이 있기 때문에 이해하기도 쉽다.`
  - 추가적으로 `설계와 함께 코드 역시 재사용`할 수 있다.

### 제어 역전 원리
- 상위 정책을 재사용한다는 것은 `결국 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용`한다는 것을 의미한다.
  - 객체지향 설계의 재사용성은 `개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름`으로부터 나온다.
  - 그리고 그 뒤에는 항상 `의존성 역전 원리`라는 강력한 지원군이 존재한다.
  - 의존성 역전 원리는 `전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리`다.
  - 의존성 역전 원리에 따라 구축되지 않은 시스템은 `협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.`
- 시스템이 진화하는 방향에는 `항상 의존성 역전 원리를 따르는 설계가 존재`해야 한다.
  - 만약 요구사항이 빠르게 진화하는 코드에서 의존성 역전 원리가 적절하게 지켜지지 않고 있다면 그곳에는 `변경을 적절하게 수용할 수 없는 하향식 절차적인 코드가 존재할 수밖에 없다.`
- 의존성 역전 원리는 `프레임워크의 가장 기본적인 설계 메커니즘`이다.
  - 의존성 역전은 `의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전`시킨다.
  - 의존성을 역전시킨 객체지향 구조에서는 `반대로 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출`한다.
  - 따라서 프레임워크를 사용할 경우 `개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동`한다.
  - 즉, `의존성을 역전시키면 제어 흐름의 주체 역시 역전`된다.
- 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 잇는 특정한 동작은 비워둔다.
  - 그리고 이렇게 완성되지 않은 채 남겨진 동작을 `훅`이라고 부른다.
  - 훅의 구현 방식은 `애플리케이션의 컨텍스트에 따라 달라진다.`
  - 훅은 프레임워크 코드에서 호출하는 프레임워크의 특정 부분이다.
  - 재정의된 훅은 `제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출`된다.
- 여기서 `협력을 제어하는 것은 프레임워크라는 것에 주목`하라.
  - `우리는 프레임워크가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐`이다.
  - 제어가 `우리에게서 프레임워크로 넘어가 버린 것`이다.
- 우리의 코드는 `수동적인 존재`다.
  - 프레임워크가 우리의 코드를 호출해줄 때까지 그저 넋 놓고 기다리고 있을 수밖에 없다.
- 만약 프레임워크를 처음 사용한다면 제어 흐름이 손가락 사이로 스멀스멀 빠져나가는 듯한 느낌에 불안해질 수도 있다.
  - 그러나 이러한 제어의 역전이 프레임워크의 핵심 개념인 동시에 코드의 재사용을 가능하게 하는 힘이라는 사실을 이해해야 한다.