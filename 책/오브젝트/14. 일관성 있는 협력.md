# 14장 일관성 있는 협력
- 가능하면 `유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용`하라.
  - 객체들의 협력이 전체적으로 일관성 있는 유사한 패턴을 따른다면 시스템을 이해하고 확장하기 위해 요구되는 정신적인 부담을 크게 줄일 수 있다.

## 01. 핸드폰 과금 시스템 변경하기
### 구간별 방식 구현하기
- 비일관성은 두 가지 상황에서 발목을 잡는다.
  - 하나는 `새로운 구현을 추가해야 하는 상황`이고, 또 다른 하나는 `기존의 구현을 이해해야 하는 상황`이다.
  - 그리고 이 장애물이 문제인 이유는 개발자로서 우리가 수행하는 대부분의 활동이 `코드를 추가하고 이해하는 일과 깊숙히 연관`돼 있기 때문이다.
- 일관성 없는 코드의 문제점은 `코드를 이해하기 어렵다는 것`이다.
  - 서로 다른 구현 방식이 코드를 이해하는 데 오히려 방해가 될 뿐이다.
- 대부분의 사람들은 유사한 요구사항을 구현하는 코드는 `유사한 방식으로 구현될 것이라고 예상`한다.
  - 하지만 `유사한 요구사항이 서로 다른 방식으로 구현돼 있다면 요구사항이 유사하다는 사실 자체도 의심`하게 될 것이다.
  - 유사한 요구사항을 구현하는 서로 다른 구조의 코드는 `코드를 이해하는 데 심리적인 장벽`을 만든다.
- 결론은 `유사한 기능을 서로 다른 방식으로 구현해서는 안 된다는 것`이다.
  - 일관성 없는 설계와 마주한 개발자는 여러 가지 해결 방법 중에서 현재의 요구사항을 해결하기에 `가장 적절한 방법을 찾아야 하는 부담을 안게` 된다.
- 유사한 기능은 `유사한 방식으로 구현`해야 한다.
  - 객체지향에서 기능을 구현하는 유일한 방법은 `객체 사이의 협력을 만드는 것뿐`이므로 유지보수 가능한 시스템을 구축하는 첫걸음은 `협력을 일관성 있게 만드는 것`이다.


## 02. 설계에 일관성 부여하기
- 일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 `다양한 설계 경험을 익히라는 것`이다.
  - 풍부한 설계 경험을 가진 사람은 어떤 변경이 중요한지, 그리고 그 변경을 어떻게 다뤄야 하는지에 대한 통찰력을 가지게 된다.
  - 따라서 설계 경험이 풍부하면 풍부할수록 `어떤 위치에서 일관성을 보장해야 하고 일관성을 제공하기 위해 어떤 방법을 사용해야 하는지를 직관적으로 결정`할 수 있다.
  - 하지만 이런 `설계 경험을 단기간에 쌓아 올리는 것은 생각보다 어려운 일`이다.
- 일관성 있는 설계를 위한 두 번째 조언은 `널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용`해보라는 것이다.
  - 디자인 패턴은 `특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 템플릿`이다.
- 협력을 일관성 있게 만들기 위한 기본 지침
  - `변하는 개념을 변하지 않는 개념으로 분리하라`
  - `변하는 개념을 캡슐화하라`

### 조건 로직 vs 객체 탐색
- `조건에 따라 분기되는 어떤 로직들이 있다면 이 로직들이 바로 개별적인 변경`이라고 볼 수 있다.
  - 절차지향 프로그램에서 변경을 처리하는 전통적인 방법은 `이처럼 조건문의 분기를 추가하거나 개별 분기 로직을 수정하는 것`이다.
  - 객체지향에서 변경을 다루는 전통적인 방법은 `조건 로직을 객체 사이의 이동으로 바꾸는 것`이다.
- 다형성은 `조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법`이다.
- 실제로 협력에 참여하는 주체는 `구체적인 객체`다.
  - 서브타입들은 협력 안에서 대체할 수 있어야 한다.
- 지금까지 살펴본 것처럼 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 `커다란 클래스를 더 작은 클래스들로 분리`해야 한다.
  - 가장 중요한 기준은 `변경의 이유와 주기`다.
  - 클래스는 명확히 `단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경`돼야 한다.
  - 간단하게 말해서 `단일 책임 원칙을 따르도록 클래스를 분리`해야 한다.
- 큰 메서드 안에 뭉쳐있던 조건 로직들을 변경의 압력에 맞춰 작은 클래스들로 분리하고 나면 `인스턴스들 사이의 협력 패턴에 일관성을 부여`하기가 더 쉬워진다.
  - `유사한 행동을 수행하는 작은 클래스들이 자연스럽게 역할이라는 추상화로 묶이게` 되고 `역할 사이에서 이뤄지는 협력 방식이 전체 설계의 일관성을 유지`할 수 있게 이끌어주기 때문이다.

### 일관성 있는 협력을 위한 지침
- `변하는 개념을 변하지 않는 개념으로부터 분리하라`
- `변하는 개념을 캡슐화하라`
  - 핵심은 훌륭한 추상화를 찾아 `추상화에 의존하도록 만드는 것`이다.
    - 추상화에 대한 의존은 `결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계`할 수 있게 해준다.
    - 따라서 선택하는 `추상화의 품질이 캡슐화의 품질을 결정`한다.
  - `변경에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴`을 얻을 수 있다.

### 캡슐화 다시 살펴보기
- 많은 사람들이 객체의 캡슐화에 관한 이야기를 들으면 반사적으로 `데이터 은닉`을 떠올린다.
  - 데이터 은닉이란 클래스의 모든 인스턴스 변수는 private으로 선언해야 하고 오직 해당 클래스의 메서드만이 인스턴스 변수에 접근할 수 있어야 한다는 것이다.
- 그러나 캡슐화는 `데이터 은닉 이상`이다.
  - 캡슐화란 단순히 `데이터를 감추는 것이 아니다.`
  - 소프트웨어 안에서 변할 수 있는 모든 '개념'을 감추는 것이다.
- 캡슐화란 `변하는 어떤 것이든 감추는 것`이다.
- 캡슐화의 가장 대표적인 예는 `객체의 퍼블릭 인터페이스와 구현을 분리`하는 것이다.
  - 객체를 구현한 개발자는 `필요할 때 객체의 내부 구현을 수정하기를 원한다.`
  - 객체와 협력하는 클라이언트의 개발자는 `객체의 인터페이스가 변하지 않기를 원한다.`
  - 따라서 `자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야 한다.`
- 다시 한번 강조하자면 `캡슐화란 단순히 데이터를 감추는 것이 아니다.`
  - `소프트웨어 안에서 변할 수 있는 어떤 '개념'이라도 감추는 것`이다.
- `코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종`이다.
  - 일반적으로 `데이터 캡슐화와 메서드 캡슐화는 개별 객체에 대한 변경을 관리하기 위해 사용`하고 `객체 캡슐화와 서브타입 캡슐화는 협력에 참여하는 객체들의 관계에 대한 변경을 관리하기 위해 사용`한다.
- 변경을 캡슐화할 수 있는 다양한 방법이 존재하지만 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 `서브타입 캡슐화와 객체 캡슐화를 조합하는 것`이다.
  - `서브타입 캡슐화는 인터페이스 상속을 사용`하고, `객체 캡슐화는 합성을 사용`한다.
- 서브타입 캡슐화와 객체 캡슐화를 적용하는 방법
  - `변하는 부분을 분리해서 타입 계층을 만든다`
    - 변하지 않는 부분으로부터 변하는 부분을 분리한다.
    - 변하는 부분들의 공통적인 행동을 `추상 클래스나 인터페이스로 추상화한 후 변하는 부분들이 이 추상 클래스나 인터페이스를 상속`받게 만든다.
    - 이제 변하는 부분은 `변하지 않는 부분의 서브타입`이 된다.
  - `변하지 않는 부분의 일부로 타입 계층을 합성한다`
    - 앞에서 구현한 타입 계층을 변하지 않는 부분에 합성한다.
    - `변하지 않는 부분에서는 변경되는 구체적인 사항에 결합돼서는 안된다.`
    - `의존성 주입과 같이 결합도를 느슨하게 유지할 수 있는 방법을 이용해 오직 추상화에만 의존`하게 만든다.


## 03. 일관성 있는 기본 정책 구현하기
### 변경 분리하기
- 일관성 있는 협력을 만들기 위한 첫 번째 단계는 `변하는 개념과 변하지 않는 개념을 분리하는 것`이다.

### 변경 캡슐화하기
- 협력을 일관성 있게 만들기 위해서는 `변경을 캡슐화해서 파급효과를 줄여야 한다.`
  - 변경을 캡슐화하는 가장 좋은 방법은 `변하지 않는 부분으로부터 변하는 부분을 분리하는 것`이다.
  - 물론 `변하는 부분의 공통점을 추상화하는 것도 잊어서는 안된다.`
  - 이제 변하지 않는 부분이 오직 이 `추상화에만 의존하도록 관계를 제한하면 변경을 캡슐화`할 수 있게 된다.

### 협력 패턴 설계하기
- 변하는 부분과 변하지 않는 부분을 분리하고, 변하는 부분을 적절히 추상화하고 나면 변하는 부분을 생략한 채 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기 할 수 있다.
- 추상화만으로 구성한 협력은 `추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장`할 수 있게 된다.
  - 다시 말해서 `재사용 가능한 협력 패턴이 선명하게 드러나는 것`이다.

### 추상화 수준에서 협력 패턴 구현하기
- 변하는 것과 변하지 않는 것을 분리하고 변하는 것을 캡슐화한 코드는 `오로지 변하지 않는 것과 추상화에 대한 의존성만으로도 전체적인 협력을 구현`할 수 있다.
  - 변하는 것은 `추상화 뒤에 캡슐화되어 숨겨져 있기 때문에 전체적인 협력의 구조에 영향을 미치지 않는다.`

### 구체적인 협력 구현하기
- 일관성 있는 협력은 `개발자에게 확장 포인트를 강제하기 때문에 정해진 구조를 우회하기 어렵게 만든다.`
  - 개발자는 `코드의 형태로 주어진 제약 안에 머물러야 하지만 작은 문제에 집중할 수 있는 자유`를 얻는다.
  - 그리고 이 작은 문제에 대한 해결책을 전체 문맥에 연결함으로써 `협력을 확장하고 구체화`할 수 있다.
- 협력을 일관성 있게 만들면 상황이 달라진다.
  - 변하지 않는 부분은 `모든 부분에서 공통적이라는 것을 기억`하라.
  - 이 공통 코드의 구조와 협력 패턴은 `모든 부분에 걸쳐 동일하기 때문에 코드를 한 번 이해하면 이 지식을 다른 코드를 이해하는 데 그대로 적용`할 수 있다.
- 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 `객체지향 시스템에서 개념적 무결성`을 유지할 수 있는 가장 효과적인 방법이다.
  - 개념적 무결성을 일관성과 동일한 뜻으로 간주해도 무방하다.
  - 시스템이 일관성 있는 몇 개의 협력 패턴으로 구성된다면 시스템을 이해하고, 수정하고, 확장하는 데 필요한 노력과 시간을 아낄 수 있다.
  - 따라서 `협력을 설계하고 있다면 항상 기존의 협력 패턴을 따를 수는 없는지 고민`하라.
    - 그것이 `시스템의 개념적 무결성을 지키는 최선의 방법`일 것이다.
  
### 협력 패턴에 맞추기
- `가급적 기존의 협력 패턴에 맞추는 것도 가장 좋은 방법`이다.
  - 비록 설계를 약간 비트는 것이 조금은 이상한 구조를 낳더라도 `전체적으로 일관성을 유지할 수 있는 설계를 선택하는 것이 현명`하다.

### 패턴을 찾아라
- 일관성 있는 협력의 핵심은 `변경을 분리하고 캡슐화`하는 것이다.
  - 변경을 캡슐화하는 방법이 `협력에 참여하는 객체들의 역할과 책임을 결정하고 이렇게 결정된 협력이 코드의 구조를 결정`한다.
  - 따라서 훌륭한 설계자가 되는 첫걸음은 `변경의 방향을 파악할 수 있는 날카로운 감각을 기르는 것`이다.
  - 그리고 이 변경에 `탄력적으로 대응할 수 있는 다양한 캡슐화 방법과 설계 방법을 익히는 것 역시 중요`하다.
- 애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 `변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후`, 이 `추상화에 변하지 않는 공통적인 책임을 할당`하라.
  - 현재의 구조가 변경을 캡슐화하기에 적합하지 않다면 `코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 협력과 코드를 리팩터링`하라.
  - `변경을 수용할 수 있는 적절한 역할과 책임을 찾다 보면 협력의 일관성이 서서히 윤곽`을 드러낼 것이다.
- 협력을 일관성 있게 만드는 과정은 `유사한 기능을 구현하기 위해 반복적으로 적용할 수 있는 협력의 구조를 찾아가는 기나긴 여정`이다.
  - 따라서 협력을 일관성 있게 만든다는 것은 `유사한 변경을 수용할 수 있는 협력 패턴을 반경하는 것과 동일`하다.