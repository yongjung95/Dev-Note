# 5장 책임 할당하기
## 개요
- 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 `어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것`이다.
- 책임 할당 과점은 일종의 트레이드오프 활동이다.
  - `동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재`하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다.
  - 따라서 `올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가`할 수 있어야 한다.


## 01. 책임 주도 설계를 향해
- 데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해선느 두 가지 원칙을 따라야 한다.
  - `데이터보다 행동을 먼저 결정`하라.
  - `협력이라는 문맥 안에서 책임을 결정`하라.

### 데이터보다 행동을 먼저 결정하라
- 객체에게 중요한 것은 `데이터가 아니라 외부에 제공하는 행동`이다.
  - 클라이언트의 관점에서 `객체가 수행하는 행동이란 곧 객체의 책임을 의미`한다.
  - 객체는 `협력에 참여하기 위해 존재하며 협력 안에서 수행하는 책임이 객체의 존재가치를 증명`한다.
- 책임 중심의 설계에서는 `객체의 행동, 즉 책임을 먼저 결정한 후에 객체의 상태를 결정`한다는 것이다.
- 객체지향 설계에서 가장 중요한 것은 `적절한 객체에게 적절한 책임을 할당하는 능력`이다.

### 협력이라는 문맥 안에서 책임을 결정하라
- 객체에서 할당된 책임의 품질은 `협력에 적합한 정도로 결정`된다.
  - 책임은 `객체의 입장이 아니라 객체가 참여하는 협력에 적합`해야 한다.
- 협력에 적합한 책임이란 `메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미`한다.
  - 다시 말해서 `메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당`해야 한다는 것이다.
- 협력에 적합한 책임을 수확하기 위해서는 `객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시지를 결정한 후에 객체를 선택`해야 한다.
- `메시지가 클라이언트의 의도를 표현한다는 사실에 주목`하라.
  - `객체를 결정하기 전에 객체가 수신할 메시지를 먼저 결정한다는 점 역시 주목`하라.
- 책임 중심의 설계가 `응집도가 높고 결합도가 낮으며 변경하기 쉽다고 말하는 이유`가 여기에 있다.
- 정리
  - `객체에게 적절한 책임을 할당하기 위해서는 협력이라는 문맥을 고려`해야 한다.
    - 협력이라는 문맥에서 적절한 책임이란 곧 `클라이언트의 관점에서 적절한 책임을 의미`한다.
  - 올바른 객체지향 설계는 `클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는 데 필요한 내부 데이터에 관해 고민하기 시작`한다.
  - 결론적으로 책임 중심의 설계에서는 `협력이라는 문맥 안에서 객체가 수행할 책임에 초점`을 맞춘다.
  
### 책임 주도 설계
- 책임 주도 설계의 흐름
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
  - 시스템 책임을 더 작은 책임으로 분할한다.
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
  - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
- 책임 주도 설계의 핵심은 `책임을 결정한 후에 책임을 수행할 객체를 결정`하는 것이다.
  - 그리고 협력에 참여하는 객체들의 책임이 어느 정도 정리될 때까지는 `객체의 내부 상태에 대해 관심을 가지지 않는 것`이다.


## 02. 책임 할당을 위한 GRASP 패턴
- `GRASP 패턴`
  - `객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리`한 것이다.

### 도메인 개념에서 출발하기
- 설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다.
  - 도메인 안에는 무수히 많은 개념들이 존재하며 이 `도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 좀 더 수월`해진다.
  - 따라서 `어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념`이다.
- 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다.
  - 단지 `우리에게 출발점이 필요할 뿐`이다.
- 중요한 것은 `설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아니다.`
  - 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 `빠르게 설계와 구현을 진행`하라.

### 정보 전문가에게 책임을 할당하라
- 책임 주도 설계 방식의 첫 단계는 `애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각`하는 것이다.
  - 이 책임을 `애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작`한다.
- 객체의 책임과 책임을 수행하는 데 필요한 상태는 `동일한 객체 안에 존재`해야 한다.
  - 따라서 객체에게 책임을 할당하는 첫 번째 원칙은 `책임을 수행할 정보를 알고 있는 객체에게 책임을 할당`하는 것이다.
  - GRASP에서는 이를 `INFOMATION EXPERT(정보 전문가) 패턴`이라고 부른다.
- INFOMATION EXPERT(정보 전문가) 패턴은 `객체가 자신이 소유하고 있는 정보와 관련된 작업을 수행한다는 일반적인 직관을 표현`한 것이다.
  - 여기서 이야기 하는 정보는 데이터와 다르다는 사실을 주의.
- `책임을 수행하는 객체가 정보를 '알고' 있다고 해서 그 정보를 '저장'하고 있을 필요는 없다.`
  - 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산할 수도 있다.
  - 어떤 방식이건 `정보 전문가가 데이터를 반드시 저장하고 있을 필요는 없다는 사실을 이해하는 것이 중요`하다.
- 현재 단계에서는 `개략적인 수준에서 객체들의 책임을 결정하는 단계이기 때문에 너무 세세한 부분까지 고민할 필요는 없다.`
  - `정보 전문가가 책임을 수행하는 데 핊요한 작업을 구상해보고 스스로 처리할 수 없는 작업이 무엇인지를 가릴 정도의 수준`이면 된다.
  - 만약 스스로 처리할 수 없는 작업이 있다면 `외부에 도움을 요청`해야 한다.
  - 이 요청이 외부로 전송해야 하는 새로운 메시지가 되고, `최종적으로 이 메시지가 새로운 객체의 책임으로 할당`된다.
- 정리
  - INFOMATION EXPERT(정보 전문가) 패턴은 `객체에게 책임을 할당할 때 가장 기본이 되는 책임 할당 원칙`이다.
  - INFOMATION EXPERT(정보 전문가) 패턴은 `객체란 상태와 행동을 함께 가지는 단위라는 객체지향의 가장 기본적인 원리를 책임 할당의 관점에서 표현`한다.
  - INFOMATION EXPERT(정보 전문가) 패턴을 따르는 것만으로도 `자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아지는 것`이다.

### 높은 응집도와 낮은 결합도
- 실제로 설계를 진행하다 보면 몇 가지 설계 중에서 한 가지 선택해야 하는 경우가 빈번하게 발생한다.
  - 이 경우네는 올바른 책임 할당을 위해 INFOMATION EXPERT(정보 전문가) 패턴 이외의 다른 책임 할당 패턴들을 함께 고려할 필요가 있다.
- 높은 응집도와 낮은 결합도는 `객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리`다.
- 책임을 할당할 수 있는 다양한 대안들이 존재한다면 `응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다.`
  - 다시 말해 두 협력 패턴 중에서 `높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택`해야 한다는 것이다.
- LOW COUPLING(낮은 결합도) 패턴과 HIGH COHESION(높은 응집도) 패턴은 `설계를 진행하면서 책임과 협력의 품질을 검토하는 데 사용할 수 있는 중요한 평가 기준`이다.
  - 책임을 할당하고 코드를 작성하는 매순간 마다 LOW COUPLING(낮은 결합도)과 HIGH COHESION(높은 응집도)의 관점에서 전체적인 설계 품질을 검토하면 `단순하면서도 재사용 가능하고 유연한 설계`를 얻을 수 있을 것이다.

### 창조자에게 객체 생성 책임을 할당하라
- CREATOR(창조자) 패턴은 `객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공`한다.


## 03. 구현을 통한 검증
- 내부 구현에 어떤 지식도 없이 전송할 메시지를 결정한다면
  - `구현을 고려하지 않고 필요한 메시지를 결정하면 내부 구현을 깔끔하게 캡슐화`할 수 있다.
- 메시지가 객체를 선택하도록 `책임 주도 설계의 방식을 따르면 캡슐화와 낮은 결합도라는 목표를 비교적 손쉽게 달성`할 수 있다.

### 변경에 취약한 클래스 개선하기
- 변경에 취약한 클래스란?
  - 코드를 수정해야 하는 이유를 하나 이상 가지는 클래스다.
- 낮은 응집도가 초래하는 문제를 해결하기 위해서는 `변경의 이유에 따라 클래스를 분리`해야 한다.
- 코드를 통해 변경의 이유를 파악할 수 있는 방법
  - `인스턴스 변수가 초기화되는 시점을 살펴보는 것`이다.
    - 응집도가 높은 클래스는 `인스턴스를 생성할 때 모든 속성을 함께 초기화`한다.
    - 반면 응집도가 낮은 클래스는 `객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않는 상태`로 남겨진다.
    - `함께 초기화되는 속성을 기준으로 코드를 분리`해야 한다.
  - `메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것`이다.
    - `모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다`고 볼 수 있다.
    - 반면 `메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다`고 볼 수 있다.
    - 이 경우 클래스의 응집도를 높이기 위해서는 `속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리`해야 한다.

### 다형성을 통해 분리하기
- `역할을 사용하면 객체의 구체적인 타입을 추상화`할 수 있다.
  - 자바에서는 일반적으로 역할을 구현하기 위해 `추상 클래스나 인터페이스를 사용`한다.
  - 역할을 대체할 클래스들 사이에서 `구현을 공유해야 할 필요가 있다면 추상 클래스를 사용`하면 된다.
  - 구현을 공유할 필요 없이 역할을 대체하는 `객체들의 책임만 정의하고 싶다면 인터페이스를 사용`하면 된다.
- `객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당`하라는 것이다.
  - 이를 POLYMORPHISM(다형성) 패턴 이라고 부른다.

### 변경으로부터 보호하기
- `변경을 캡슐화하도록 책임을 할당`하는 것을 PROTECTED VARIATIONS(변경 보호) 패턴이라고 부른다.
- `클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하는 것은 설계의 결합도와 응집도를 향상시키는 매우 강력한 방법`이다.
- 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 `클래스를 분해하고 POLYMORPHISM(다형성) 패턴에 따라 책임을 분산`시켜라.
- 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 `PROTECTED VARIATIONS(변경 보호) 패턴에 따라 안정적인 인터페이스를 뒤로 변경을 캡슐화`하라.
- 적절한 상황에서 `두 패턴을 조합하면 코드 수정의 파급 효과를 조절할 수 있고 변경과 확장에 유연하게 대처할 수 있는 설계를 얻을 수 있을 것`이다.

### 책임 중심의 영화 예매 시스템으로 개선하기
![img.png](사진폴더/05/5.7%20책임%20중심의%20영화%20예매%20시스템.png)
- `모든 클래스의 내부 구현은 캡슐화돼 있고 모든 클래스는 변경의 이유를 오직 하나씩`만 가진다.
  - 각 클래스는 `응집도가 높고 다른 클래스와 최대한 느슨하게 결합`돼 있다.
  - 클래스는 `작고 오진 한 가지 일만 수행`한다.
- `책임은 적절하게 분배`돼 있다.
  - 이것이 `책임을 중심으로 협력을 설계할 때 얻을 수 있는 혜택`이다.
- 결론은 `데이터가 아닌 책임을 중심으로 설계`하라는 것이다.
  - 객체에게 중요한 것은 `상태가 아니라 행동`이다.
  - 객체지향 설계의 기본은 `책임과 협력에 초점을 맞추는 것`이다.

### 변경과 유연성
- 설계를 주도하는 것은 `변경`이다.
- 변경에 대비할 수 있는 방법
  - `코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것`이다.
  - `코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것`이다.
  - 대부분의 경우에 전자가 더 좋은 방법이지만 유사한 변경이 반복적으로 발생하고 있다면 복잡성이 상승하더라도 유연성을 추가하는 두 번째 방법이 더 좋다.
- 상속 대신 `합성을 사용`하기
  - 코드의 복잡성이 높아지더라도 `정책의 변경을 쉽게 수용할 수 있게 코드를 유연하게 만드는 방법`이다.
- 실제로 유연성은 `의존성 관리의 문제`다.
  - `요소들 사이의 의존성의 정도가 유연성의 정도를 결정`한다.
  - 유연성의 정도에 따라 결합도를 조절할 수 있는 능력은 객체지향 개발자가 갖춰야 하는 중요한 기술 중 하나다.


## 04. 책임 주도 설계의 대안
- 책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해 선택하는 방법은 `최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것`이다.
  - 아무것도 없는 상태에서 책임과 협력에 고나해 고민하기보다는 일단 실행되는 코드를 얻고 난 후에 `코드 상에 명확하게 드러나는 책임들을 올바른 위치로 이동`시키는 것이다.
- 주의할 점은 `코드를 수정한 후에 겉으로 드러나는 동작이 바뀌어서는 안 된다는 것`이다.
  - 캡슐화를 항상시키고, 응집도를 높이고, 결합도를 낮춰야 하지만 `동작은 그대로 유지`해야 한다.
  - 이처럼 `이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경`하는 것은 `리팩터링`이라고 부른다.

### 메서드 응집도
- 긴 메서드는 `다양한 측면에서 코드의 유지보수에 부정적인 영향`을 미친다.
  - 어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는 데 너무 많은 시간이 걸린다.
  - 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
  - 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.
  - 로직의 일부만 재사용하는 것이 불가능하다.
  - 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.
- 긴 메서드는 `응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다.`
- 응집도가 낮은 메서드는 `로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분`이다.
  - 주석을 추가하는 대신 `메서드를 작게 분해해서 각 메서드의 응집도를 높여라.`
- 클래스의 응집도와 마찬가지로 `메서드의 응집도를 높이는 이유도 변경과 관련이 깊다.`
  - `응집도 높은 메서드는 변경되는 이유가 단 하나`여야 한다.
  - 클래스가 작고, 목적이 명확한 메서드들로 구성돼 있다면 `변경을 처리하기 위해 어떤 메서드를 수정해야 하는지를 쉽게 판단`할 수 있다.
  - `메서드의 크기가 작고 목적이 분명하기 때문에 재사용`하기도 쉽다.
  - 작은 메서드들로 조합된 메서드는 `마치 주석들을 나열한 것처럼 보이기 때문에 코드를 이해`하기도 쉽다.
- 객체로 책임을 분배할 때 가장 먼저 할 일은 `메서드를 응집도 있는 수준으로 분해`하는 것이다.
  - 긴 메서드를 작고 응집도 높은 메서드로 분리하면 `각 메서드를 적절한 클래스로 이동하기가 수월`해지기 때문이다.
- 작고, 명확하며, 한 가지 일에 집중하는 응집도 높은 메서드는 `변경 가능한 설계를 이끌어 내는 기반`이 된다.
  - 이런 메서드들이 하나의 변경을 이유를 가지도록 개선될 때 `결과적으로 응집도 높은 클래스`가 만들어진다.

### 객체를 자율적으로 만들자
- `자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길`이다.
  - 따라서 `메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동`시키면 된다.
- 어떤 데이터를 사용하는지를 가장 쉽게 알 수 있는 방법은 `메서드 안에서 어떤 클래스의 접근자 메서드를 사용하는지 파악`하는 것이다.
- 이처럼 메서드를 다른 클래스로 이동시킬 때는 `인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적`이다.
  - 이렇게 되면 `모든 접근자 메서드를 제거`할 수 있고, `필요한 로직이 한 곳에 모여 있기 때문에 응집도 역시 높아졌다.`
- 이처럼 `데이터를 사용하는 메서드를 데이터를 가진 클래스로 이동시키고 나면 캡슐화와 높은 응집도, 낮은 결합도를 가지는 설계`를 얻게 된다.
- 정리
  - 책임 주도 설계 방법에 익숙하지 않다면 일단 `데이터 중심으로 구현한 후 이를 리팩터링하더라도 유사한 결과를 얻을 수 있다는 것`이다.
  - 처음부터 책임 주도 설계 방법을 따르는 것보다 `동작하는 코드를 작성한 후에 리팩터링하는 것이 더 훌륭한 결과물`을 낳을 수도 있다.
  - `캡슐화, 결합도, 응집도를 이해하고 훌륭한 객체지향 원칙을 적용하기 위해 노력한다면 책임 주도 설계 방법을 단계적으로 따르지 않더라도 유연하고 깔끔한 코드를 얻을 수 있을 것이다.`