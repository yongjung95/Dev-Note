# 10장 상속과 코드 재사용
## 01. 상속과 중복 코드
- 붕복 코드는 우리를 주저하게 만들뿐만 아니라 동료들을 의심하게 만든다.
  - 이것만으로도 `중복 코드를 제거해야 할 충분한 이유`가 되고도 남겠지만 결정적인 이유는 따로 있다.

### DRY 원칙
- 중복 코드는 `변경을 방해`한다.
  - 프로그램의 본질은 `비즈니스와 관련된 지식을 코드로 변환`하는 것이다.
- 중복 코드가 가지는 가장 큰 문제는 `코드를 수정하는 데 필요한 노력을 몇 배로 증가`시킨다는 것이다.
  - 중복 코드는 `수정과 테스트에 드는 비용을 증가시킬뿐만 아니라 시스템과 여러분을 공황상태로 몰아`넣을 수도 있다.
- 중복 여부를 판단하는 기준은 `변경`이다.
  - `요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복`이다.
  - 중복 여부를 결정하는 기준은 `코드가 변경에 반응하는 방식`이다.
- 신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는 효과적인 방법 중 하나는 `중복을 제거하는 것`이다.
  - `DRY 원칙`를 따르면 된다.
    - Don't Repeat Yourself의 첫 글자를 모아 만든 용어로 간단히 말해 `동일한 지식을 중복하지 말라는 것`이다.

### 중복과 변경
- 중복 코드는 새로운 중복 코드를 부른다.
  - 중복 코드를 제거하지 않은 상태에서 코드를 숮어할 수 있는 유일한 방법은 `새로운 중복 코드를 추가하는 것`뿐이다.
  - 중복 코드가 늘어날수록 `애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아진다는 것`이다.

#### 타입 코드 사용하기
- 두 클래스 사이의 중복 코드를 제거하는 한 가지 방법은 `클래스를 하나로 합치는 것`이다.
  - 구분하는 타입 코드를 추가하고 타입 코드의 값에 따라 로직을 분기시키는 방법
  - 하지만 계속 강조했던 것처럼 타입 코드를 사용하는 클래스는 `낮은 응집도와 높은 결합도라는 문제`에 시달리게 된다.
- 객체지향 프로그래밍 언어는 타입 코드를 사용하지 않고도 중복 코드를 관리할 수 있는 효과적인 방법을 제공한다.
  - 이 방법은 너무나 유명해서 객체지향 프로그래밍을 대표하는 기법으로 일컬어지기도 한다.
  - 바로 `상속`이다.
  
### 상속을 이용해서 중복 코드 제거하기
- 상속의 기본 아이디어는 매우 간단하다.
  - 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 `상속을 이용해 코드를 재사용하라는 것`이다.
- 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각처럼 쉽지 않다.
  - 개발자는 재사용을 위해 상속 계층 사이에 무수히 많은 가정을 세웠을지도 모른다.
  - 그리고 그 가정은 코드를 이해하기 어렵게 만들뿐만 아니라 직관에도 어긋날 수 있다.
- 상속을 이용해 코드를 재사용하기 위해서는 `부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해`해야 한다.
  - 이것은 `자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미`한다.
- 따라서 상속은 `결합도를 높인다.`
  - 그리고 `상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.`
- 상속을 사용하면 적은 노력으로도 새로운 기능을 쉽고, 빠르게 추가할 수 있다.
  - 하지만 그로인해 `커다란 대가`를 치러야 할 수도 있다.
- 이처럼 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 `취약한 기반 클래스 문제`라고 부른다.


## 02. 취약한 기반 클래스 문제
- 취약한 기반 클래스 문제
  - `부모 클래스의 변경에 의해 자식 클래스가 영향`을 받는 현상
- `상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실`을 알고 있어야 한다.
- 취약한 기반 클래스 문제는 `캡슐화를 약화시키고 결합도를 높인다.`
  - 상속은 `자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화`시킨다.
- 객체를 사용하는 이유는 `구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화`할 수 있기 때문이다.
  - 캡슐화는 `변경에 의한 파급효과를 제어`할 수 있기 때문에 가치가 있다.
  - 객체는 변경될지도 모르는 불안정한 요소를 캡슐화함으로써 파급효과를 걱정하지 않고도 자유롭게 내부를 변경할 수 있다.
- 상속을 사용하면 `부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받기 쉬워`진다.
- 객체지향의 기반은 `캡슐화를 통한 변경의 통제`다.
  - 상속은 코드의 재사용을 위해 `캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감`시킨다.

### 불필요한 인터페이스 상속 문제
- 인터페이스 설계는 `제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게` 만들어야 한다.
  - 개발자 한 사람의 일시적인 편의를 위해 인터페이스를 사용해야 하는 무수한 사람들이 가슴을 졸여야 하는 상황을 초래하는 것은 어떤 경우에도 정당화하기 어렵다.
- 객체지향의 핵심은 `객체들의 협력`이다.
  - 단순히 코드를 재사용하기 위해 `불필요한 오퍼레이션이 인터페이스에 스며들도록 방치`해서는 안된다.

### 메서드 오버라이딩의 오작용 문제
- `미래에 발생할지 모르는 위험을 방지하기 위해 코드를 중복`시키면 안된다.
  - 게다가 `부모 클래스의 코드를 그대로 가져오는 방법`이 항상 가능한 것도 아니다.
- 클래스가 상속되기를 원한다면 `상속을 위해 클래스를 설계하고 문서화`해야 하며, 그렇지 않은 경우에는 `상속을 금지`시켜야 한다고 주장한다.
- `설계는 트레이드오프 활동`이라는 사실을 기억하라.
  - `상속은 코드 재사용을 위해 캡슐화를 희생`한다.
  - 완벽한 캡슐화를 원한다면 `코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용`해야 한다.

### 부모 클래스와 자식 클래스의 동시 수정 문제
- `부모 클래스를 수정할 때 자식 클래스를 함께 수정`해야 할 수도 있다.
  - 상속을 사용하면 자식 클래스가 부모 클래스의 구현에 `강하게 결합되기 때문에 이 문제를 피하기는 어렵다.`
- 결합도란 `다른 대상에 대해 알고 있는 지식의 양`이다.
  - 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 `자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요`한다.
  - 따라서 코드 재사용을 위한 상속은 `부모 클래스와 자식 클래스를 강하게 결합`시키기 때문에 `함꼐 수정해야 하는 상황 역시 빈번하게 발생할 수밖에 없는 것`이다.


## 03. Phone 다시 살펴보기
### 추상화에 의존하자
- 코드 중복을 제거하기 위해 상속을 도입할 때 따르는 원칙
  - `두 메서드가 유사하게 보인다면 차이점을 메서드로 추출`하라.
    - 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
  - `부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라`
    - 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것 보다 자식 클래스의 추상적인 메서드를 `부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과`를 얻을 수 있다.

### 차이를 메서드로 추출하라
- 가장 먼저 할 일은 `중복 코드 안에서 차이점을 별도의 메서드로 추출`하는 것이다.

### 중복 코드를 부모 클래스로 올려라
- 공통 코드를 옮길 때 인스턴스 변수보다 메서드를 먼저 이동시키는 게 편한데, 메서드를 옮기고 나면 `그 메서드에 필요한 메서드나 인스턴스 변수가 무엇인지를 컴파일 에러를 통해 자동으로 알 수 있기 때문`이다.
- 메서드의 구현은 `그대로 두고 공통 부분인 시그니처만 부모 클래스로 이동`시켜야 한다.
- 자식 클래스들의 사이의 공통점을 부모 클래스로 옮김으로써 실제 코드를 기반으로 상속 계층을 구성할 수도 있다.

### 추상화가 핵심이다
- 공통 코드를 이동시킨 후에 각 클래스는 `서로 다른 변경의 이유를 가진다는 것에 주목`하라
  - 각 클래스는 `하나의 변경 이유만을 가진다.`
  - 이 클래스들은 `단일 책임 원칙`을 준수하기 때문에 응집도가 높다.
- 이 `설계는 낮은 결합도를 유지`하고 있다.
- 현재의 설계는 확장에는 열려 있고 수정에는 닫혀 있기 때문에 `개방-폐쇄 원칙` 역시 준수한다.
- 지금까지 살펴본 모든 장점은 `클래스들이 추상화를 의존하기 때문에 얻어지는 장점`이다.
  - `상속 계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링`하라.
  - `차이점을 메서드로 추출`하고 `공통적인 부분은 부모 클래스로 이동`하라.

### 새로운 로직 추가하기
- 클래스라는 도구는 `메서드뿐만 아니라 인스턴스 변수도 함께 포함`한다.
  - 따라서 클래스 사이의 상속은 자식 클래스가 부모 클래스가 `구현한 행동뿐만 아니라 인스턴스 변수에 대해서도 결합`되게 만든다.
- 인스턴스 변수의 목록이 변하지 않는 상황에서 객체의 행동만 변경된다면 상속 계층에 속한 각 클래스들을 독립적으로 진화시킬 수 있다.
  - 하지만 인스턴스 변수가 추가 된느 경우는 다르다.
  - 자식 클래스는 자신의 인스턴스를 생성할 때 부모 클래스에 정의된 인스턴스 변수를 초기화해야 하기 때문에 `자연스럽게 부모 클래스에 추가된 인스턴스 변수는 자식 클래스의 초기화 로직에 영향`을 미치게 된다.
  - 결과적으로 `책임을 아무리 잘 분리하더라도 인스턴스 변수의 추가는 종종 상속 계층 전반에 걸친 변경을 유발`한다.
- 하지만 `인스턴스 초기화 로직을 변경하는 것이 두 클래스에 동일한 코드를 중복시키는 것보다 현명한 선택`이다.
  - 객체 생성 로직이 변경됐을 때 영향을 받는 부분을 최소화하기 위해 노력해야 한다는 사실을 잘 알고 있을 것이다.
  - 객체 생성 로직의 변경에 유연하게 대응할 수 있는 다양한 방법이 존재한다.
  - 따라서 `객체 생성 로직에 대한 변경을 막기 보다는 핵심 로직의 중복`을 막아라.
  - 핵심 로직은 `한 곳에 모아놓고 조심스럽게 캡슐화`해야 한다.
  - 그리고 공통적인 핵심 로직은 `최대한 추상화`해야 한다.
- `상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다.`
  - 상속은 `어떤 방식으로든 부모 클래스와 자식클래스를 결합`시킨다.
  - 메서드 구현에 대한 결합은 `추상 메서드를 추가함`으로써 어느 정도 완화할 수 있지만 `인스턴스 변수에 대한 잠재적인 결합을 제거할 수 있는 방법은 없다.`
  - 우리가 원하는 것은 `행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전체에 걸쳐 부작용이 퍼지지 않게 막는 것`이다.


## 04. 차이에 의한 프로그래밍
- 상속을 이용하면 이미 존재하는 클래스의 코드를 기반으로 다른 부분을 구현함으로써 `새로운 기능을 쉽고 빠르게 추가`할 수 있다.
  - 상속이 강력한 이유는 `익숙한 개념을 이용해서 새로운 개념을 쉽고 빠르게 추가`할 수 있기 때문이다.
- 이처럼 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법은 `차이에 의한 프로그래밍`이라고 부른다.
  - 상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의가 가능해진다.
- 차이에 의한 프로그래밍의 목표는 `중복 코드를 제거하고 코드를 재사용`하는 것이다.
  - 중복을 제거하기 위해서는 `코드를 재사용 가능한 단위로 분해하고 재구성`해야 한다.
  - 코드를 재사용하기 위해서는 `중복 코드를 제거해서 하나의 모듈`로 모아야 한다.
  - 프로그래밍의 세계에서 중복 코드는 `악의 근원`이다.
- 재사용 가능한 코드란 `심각한 버그가 존재하지 않는 코드`다.
  - 따라서 코드를 재사용하면 `코드의 품질은 유지하면서도 코드를 작성하는 노력과 테스트는 줄일 수 있다.`
- 객체지향 세계에서 중복 코드를 제거하고 코드를 재사용할 수 있는 가장 유명한 방법은 `상속`이다.
  - 상속을 사용하면 `여러 클래스 사이에서 재사용 가능한 코드를 하나의 클래스` 안으로 모을 수 있다.
- 상속은 `강력한 도구`다.
  - 상속을 이용하면 새로운 기능을 추가하기 위해 `직접 구현해야하는 코드의 양을 최소화`할 수 있다.
- 하지만 상속이 코드 재사용이라는 측면에서 매우 강력한 도구인 것은 사실이지만 `강력한 만큼 잘못 사용할 경우에 돌아오는 피해 역시 크다는 사실을 뼈저리게 경험`한 것이다.
  - `상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다.`
  - `정말로 필요한 경우에만 상속을 사용`하라.
- 상속은 `코드 재사용과 관련된 대부분의 경우에 우아한 해결 방법이 아니다.`
  - 객체지향에 능숙한 개발자들은 `상속의 단점을 피하면서도 코드를 재사용할 수 있는 더 좋은 방법이 있다는 사실`을 알고 있다.
  - 바로 `합성`이다.

## 상속을 위한 경고

### 상속을 위한 경고 1
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 `두 클래스는 강하게 결합`된다.
- super 호출을 제거할 수 있는 방법을 찾아 `결합도를 제거`하라.

### 상속을 위한 경고 2
- `상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙`을 깨트릴 수 있다.

### 상속을 위한 경고 3
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 `부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합`될 수 있다.

### 상속을 위한 경고 4
- `클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택`할 수밖에 없다.