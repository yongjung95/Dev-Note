# 4장 설계 품질과 트레이드오프
## 01. 데이터 중심의 영화 예매 시스템
- 객체지향 설계에서는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.
  - 상태(데이터)를 분할의 중심축으로 삼는 방법
    - 객체는 `자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의`한다.
  - 책임을 분할의 중심축으로 삼는 방법
    - 객체는 `다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관`한다.
- 훌륭한 객체지향 설계는 데이터가 아니라 `책임에 초점`을 맞춰야 한다.
  - 객체의 상태는 구현에 속하는데, `구현은 불안정하기 때문에 변하기 쉽다.`
  - 상태를 객체 분할의 중심축으로 삼으면 `구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.`
  - 결과적으로 상태 변경은 `인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향`이 퍼지게 된다.
- 따라서 `책임에 초점을 맞추면 상대적으로 변경에 안정적인 설계`를 얻을 수 있다.

### 데이터를 준비하자
- 데이터 중심의 설계에서는 `객체가 포함해야 하는 데이터에 집중`한다.


## 02. 설계 트레이드오프
### 캡슐화
- 객체지향이 강력한 이유는 `한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공`하기 때문이다.
  - 객체를 사용하면 `변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제`할 수 있다.
- 변경될 가능성이 높은 부분은 `구현`이라고 부르고 상대적으로 안정적인 부분을 `인터페이스`라고 부른다.
  - 객체를 설계하기 위한 가장 기본적인 아이디어는 `변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절`하는 것이다.
- 캡슐화는 `외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류`다.
  - 객체지향 설계의 가장 중요한 원리는 `불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것`이다.
- 캡슐화가 중요한 이유는 `불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제`할 수 있기 때문이다.
- 정리하면 캡슐화란 `변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법`이다.

### 응집도과 결합도
- 응집도
  - `모듈에 포함된 내부 요소들이 연관돼 있는 정도`를 나타낸다.
  - 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.
- 결합도
  - `의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나태내는 척도`다.
- 애플리케이션을 구성하는 `각 요소의 응집도가 높고 서로 느슨하게 결합돼 있다면 그 애플리케이션은 좋은 설계`를 가졌다고 할 수 있다.
  - 좋은 설계란 `오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계`다.
- 높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는?
  - `설계를 변경하기 쉽게 만들기 때문`이다.
- 변경의 관점에서 응집도란
  - `변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도`로 측정할 수 있다.
  - 간단히 말해 `하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부만 변경된다면 응집도가 낮은 것`이다.
  - 또한 `하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것`이다.
  - 따라서 `응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워`진다
- 변경의 관점에서 결합도란
  - `한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도`로 측정할 수 있다.
  - 다시 말해 `하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지`를 나타낸다.
  - 따라서 `결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워`진다.
- `캡슐화의 정도가 응집도와 결합도에 영향`을 미친다.
  - `캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.`
  - 따라서 `응집도와 결합도를 고려하기 전에 먼저 캡슐화를 향상시키기 위해 노력`하라.


## 03. 데이터 중심의 영화 예매 시스템의 문제점
- 데이터 중심의 설계는 `캡슐화를 위반하기 쉽기 때문에 책임 중심의 설꼐에 비해 응집도가 낮고 결합도가 높은 객체들을 양산`하게 될 가능성이 높다.
- 데이터 중심의 설계가 가진 대표적인 문제점
  - 캡슐화 위반
  - 높은 결합도
  - 낮은 응집도
  
### 캡슐화 위반
- 설계할 때 `협력에 관해 고민을 하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향`이 있다.
  - 객체가 사용될 문맥을 추측할 수밖에 없는 경우 개발자는 `어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가`하게 되는 것이다.
- 접근자와 수정자에 과도하게 의존하는 설계 방식을 `추측에 의한 설계 전략`이라고 부른다.
  - 이 전략은 객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다.
  - 따라서 프로그래머는 내부 상태를 드러내는 메서드를 최대한 많이 추가해야 한다는 압박에 시달릴 수밖에 없으며 `결과적으로 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출`될 수밖에 없는 것이다.
  - 그 결과, `캡슐화의 원칙을 위반하는 변경에 취약한 설계`를 얻게 된다.
  - 예) @Data, @Getter, @Setter

### 높은 결합도
- 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 `여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합`된다는 것이다.
- 데이터 중심의 설계는 `전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동`칠 수밖에 없다.

### 낮은 응집도
- 어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 `설계의 응집도가 낮다는 증거`다.


## 04. 자율적인 객체를 향해
### 캡슐화를 지켜라
- 데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 근본적인 원인은 바로 `캡슐화의 원칙을 위반`했기 때문이다.
  - 객체는 `자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.`
  - 객체는 `스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근`할 수 있어야 한다.
- 여기서 말하는 메서드는 단순히 속성 하나의 값을 반환하거나 변경하는 접근자나 수정자를 의미하는 것이 아니고, `객체가 책임져야 하는 무언가를 수행하는 메서드`다.
  - 속성의 가시성을 Private 으로 설정했다고 해도 접근자와 수정자를 통해 외부로 제공하고 있다면 `캡슐화를 위반하는 것`이다.
- 접근자와 수정자를 사용시에 발생되는 문제점
  - `코드 중복`이 발생할 확률이 높다는 것이다.
    - 코드 중복은 악의 근원이다.
    - 따라서 코드 중복을 초래할 수 있는 모든 원인을 제거하는 것이 중요하다.
  - `변경에 취약`하다는 점이다.
    - 인스턴스 변수의 존재 사실을 인터페이스를 통해 외부에 노출시키게 된다.
- 해결 방법은 `캡슐화를 강화시키는 것`이다.
  - 이것이 바로 객체가 자기 스스로를 책임지게 하는 방법이다.

### 스스로 자신의 데이터를 책임지는 객체
- 우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 `객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서`다.
  - 객체는 단순한 데이터 제공자가 아니고, 객체 내부에 저장되는 데이터보다 `객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요`하다.
- 데이터를 처리하는 데 필요한 메서드를 데이터를 가지고 있는 객체 스스로 구현한다.
  - 따라서 이 말은 `객체들은 스스로를 책임`진다고 말할 수 있다.


## 05. 하지만 여전히 부족하다
### 캡슐화 위반
- 내부 구현의 변경이 외부로 퍼져나가는 `파급 효과`는 캡슐화가 부족하다는 명백한 증거다.
  - 따라서 변경 후의 설계는 자기 자신을 스스로 처리한다는 점에서 이전의 설계보다 분명히 개선됐지만 여전히 내부의 구현을 캡슐화하는 데는 실패한 것이다.

### 높은 결합도
- 모든 문제의 원인은 캡슐화 원칙을 지키지 않았기 때문이다.
  - 유연한 설계를 창조하기 위해서는 `캡슐화를 설계의 첫 번째 목표`로 삼아야 한다.

### 낮은 응집도
- 응집도가 낮은 이유는 `캡슐화를 위반`했기 때문이다.


## 06. 데이터 중심 설계의 문제점
- 캡슐화를 위반한 설계를 구성하는 요소들이 `높은 응집도와 낮은 결합도를 가질 확률은 극히 낮다.`
  - 따라서 `캡슐화를 위반한 설계는 변경에 취약`할 수 밖에 없다.
- 데이터 중심의 설계가 변경에 취약한 이유
  - `데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.`
  - `데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.`

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.
- `데이터는 구현의 일부라는 사실을 명심`하라.
  - 데이터 주도 설계는 `설계를 시작하는 처음부터 데이터에 관해 결정하도록 강요하기 때문에 너무 이른 시기에 내부 구현에 초점`을 맞추게 한다.
- 데이터 중심의 관점에서 객체는 그저 단순한 데이터의 집합체일 뿐이다.
  - 이로 인해 `접근자와 수정자를 과도하게 추가`하게 되고 `이 데이터 객체를 사용하는 절차를 분리된 별도의 객체 안에 구현`하게 된다.
- 데이터를 처리하는 작업과 데이터를 같은 객체 안에 두더라도 `데이터에 초점이 맞춰져 있다면 만족스러운 캡슐화를 얻기 어렵다.`
  - 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 `데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게` 된다.
  - 결과적으로 `객체의 인터페이스는 구현을 캡슐화하는 데 실패하고 코드는 변경에 취약`해진다.

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다
- 데이터 중심 설계에서 초점은 `객체의 외부가 아니라 내부`로 향한다.
  - `실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정`한다.
  - 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 `이미 구현된 객체의 인터페이스를 억지로 끼워맞출` 수밖에 없다.
- 객체의 인터페이스에 구현이 노출돼 있었기 때문에 `협력이 구현 세부사항에 종속`돼 있고 `그에 따라 객체의 내부 구현이 변경됐을 때 협력하는 객체 모두가 영향`을 받을 수밖에 없었던 것이다.