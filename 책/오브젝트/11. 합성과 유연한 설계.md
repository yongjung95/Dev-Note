# 11장 합성과 유연한 설계
- 상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 `코드 재사용 기법`이다.
  - 상속은 `부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용`한다.
  - 합성은 `전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용`한다.
  - 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 `컴파일타임에 해결`되지만 합성에서 두 객체 사이의 의존성은 `런타임에 해결`된다.
  - 상속과 합성은 코드 재사용이라는 동일한 목적을 가진다는 점을 제외하면 `구현 방법부터 변경을 다루는 방식에 이르기까지 모든 면에서 도드라진 차이`를 보인다.
- 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 `변경에 더 안정적인 코드`를 얻을 수 있다.
- 합성 관계는 `객체 사이의 동적인 관계`다.
  - 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 `합성 관계는 싱행 시점에 동적으로 변경`할 수 있기 때문이다.
  - 따라서 상속 대신 합성을 사용하면 `변경하기 쉽고 유연한 설계`를 얻을 수 있다.
- 변경에 유연하게 대처할 수 있는 설계가 `대부분의 경우에 정답`일 가능성이 높다.
- `코드 재사용을 위해서는 객체 합성이 클래스 상속보다 더 좋은 방법`이다.
  - 상속 대신 합성을 사용하면 구현에 대한 의존성을 `인터페이스에 대한 의존성으로 변경`할 수 있다.
  - 다시 말해서 `클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체`할 수 있는 것이다.
  

## 01. 상속을 합성으로 변경하기
 - 상속을 남용했을 때 직면하는 문제점 
   - 불필요한 인터페이스 상속 문제
   - 메서드 오버라이딩의 오작용 문제
   - 부모 클래스와 자식 클래스의 동시 수정 문제
- `합성을 사용하면 상속이 초래하는 문제점을 해결`할 수 있다.
- 상속을 합성으로 바꾸는 방법은 `자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언`하면 된다.
- 동일한 메서드를 호출하기 위해 추가된 메서드를 `포워딩 메서드`라고 부른다.
  - 포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유영한 기법이다.
- 상속과 비교해서 합성은 `안정성과 유연성`이라는 장점을 제공한다.
  - `구현이 아니라 인터페이스에 의존하면 설계가 유연`해진다.


## 02. 상속으로 인한 조합의 폭발적인 증가
- 상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다.
  - 가장 일반적인 상황은 `작은 기능을 조합해서 더 큰 기능을 수행하는 객체`를 만들어야 하는 경우다.
  - 이때 발생하는 문제점
    - 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
    - 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

### 기본 정책에 세금 정책 조합하기
- 부모 클래스의 메서드를 재사용하기 위해 super 호출을 사용하면 원하는 결과를 쉽게 얻을 수는 있지만 `자식 클래스와 부모 클래스 사이의 결합도가 높아`지고 만다.
  - 결합도를 낮추는 방법은 자식 클래스가 부모 클래스의 메서드를 호출하지 않도록 `부모 클래스에 추상 메서드를 제공`하는 것이다.
  - 부모 클래스가 자신이 정의한 추상 메서드를 호출하고 자식 클래스가 이 메서드를 오버라이딩해서 부모 클래스가 원하는 로직을 제공하도록 수정하면 부모 클래스와 자식 클래스 사이의 결합도를 느슨하게 만들 수 있다.
  - 이 방법은 자식 클래스가 부모 클래스의 구체적인 구현이 아니라 `필요한 동작의 명세에 기술하는 추상화에 의존`하도록 만든다.
- 부모 클래스에 추상 메서드를 추가하면 `모든 자식 클래스들이 추상 메서드를 오버라이딩해야 하는 문제가 발생`한다.
  - 자식 클래스의 수가 적다면 큰 문제가 아니겠지만 자식 클래스의 수가 많을 경우에는 꽤나 번거로운 일이 될 수 밖에 없다.
  - 유연성은 유지하면서도 중복 코드를 제거할 수 있는 방법은 `부모 클래스의 추상 메서드에 대한 기본 구현을 함께 제공`하는 것이다.
- 사실 자바를 비롯한 대부분의 객체지향 언어는 `단일 상속만 지원`하기 때문에 `상속으로 인해 발생하는 중복 코드 문제를 해결하기가 쉽지 않다.`

### 중복 코드의 덫에 걸리다
- 상속을 이용한 해결 방법은 모든 가능한 조합별로 자식 클래스를 하나씩 추가하는 것이다.
  - 새로운 기본 정책을 추가하면 그에 따라 조합 가능한 부가 정책의 수만큼 `새로운 클래스를 추가`해야 한다.
  - 이처럼 `상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가`해야 하는 경우를 가리켜 `클래스 폭발` 문제 또는 `조합의 폭발` 문제라고 부른다.
- 클래스 폭발 문제는 `부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계 때문에 발생하는 문제`다.
  - `컴파일타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에` 자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 `조합의 수만큼 새로운 클래스를 추가`하는 것뿐이다.
- 클래스 폭발 문제는 `새로운 기능을 추가할 때뿐만 아니라 기능을 수정할 때도 문제`가 된다.
  - 여러 클래스 안에 중복돼 있기 때문에 `모든 클래스를 찾아 동일한 방식으로 수정`해야 하기 때문이다.
- 이 문제를 해결할 수 있는 최선의 방법은 `상속을 포기하는 것`이다.


## 03. 합성 관계로 변경하기
- 상속 관계는 `컴파일 타임에 결정되고 고정`되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.
  - 따라서 `여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가`해야 한다.
- 합성은 `컴파일타임 관계를 런타임 관계로 변경`함으로써 이 문제를 해결한다.
  - 합성을 사용하면 구현이 아닌 `퍼블릭 인터페이스에 대해서만 의존`할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있다.
- 상속을 사용하는 것은 `컴파일타임의 의존성과 런타임의 의존성을 동일하게 만들겠다고 선언`하는 것이다.
  - 따라서 상속을 사용하면 `부모 클래스와 자식 클래스 사이의 관계가 정적으로 고정`되기 때문에 실행 시점에 동적으로 관계를 변경할 수 있는 방법이 없다.
- 상속과 달리 합성 관계는 `런타임에 동적으로 변경`할 수 있다.
  - 합성을 사용하면 `컴파일타임 의존성과 런타임 의존성을 다르게` 만들 수 있다.
  - 클래스 폭발 문제를 해결하기 위해 합성을 사용하는 이유는 `런타임에 객체 사이의 의존성을 자유롭게 변경`할 수 있기 때문이다.
- 합성을 사용하면 구현 시점에 정책들의 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있게 된다.
  - 상속이 `조합의 결과를 개별 클래스 안으로 밀어 넣는 방법`이라면 합성은 `조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법`을 사용하는 것이라고 할 수 있다.
  - `컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성`할 수 있다는 것이 합성이 제공하는 가장 커다란 장점인 것이다.
- 물론 `컴파일타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복잡도가 상승하기 때문에 코드를 이해하기 어려워지는 것 역시 사실`이다.
  - 하지만 `설계는 변경과 유지보수를 위해 존재한다는 사실`을 기억하라.
  - 설계는 트레이드오프의 산물이다.
  - 대부분의 경우에는 단순한 설계가 정답이지만 변경에 따르는 고통이 복잡성으로 인한 혼란을 넘어서고 있다면 `유연성의 손을 들어주는 것이 현명한 판단`일 확률이 높다.

### 기본 정책 합성하기
- 다양한 종류의 객체와 협력하기 위해 합성 관계를 사용하는 경우에는 합성하는 객체의 타입을 `인터페이스나 추상 클래스로 선언하고 의존성 주입을 사용해 런타임에 필요한 객체를 설정할 수 있도록 구현`하는 것이 일반적이다.

### 기본 정책과 부가 정책 합성하기
- 일단 설계에 익술해지고 나면 `객체를 조합하고 사용하는 방식이 상속을 사용한 방식보다 더 예측 가능하고 일관성이 있다는 사실`을 알게 될 것이다.
- 합성의 진가는 `새로운 클래스를 추가하거나 수정하는 시점에 돼서야 비로소 알 수 있다.`

### 새로운 정책 추가하기
- 우리는 오직 하나의 클래스만 추가하고 런타임에 필요한 정책들을 조합해서 원하는 기능을 얻을 수 있다.
- 더 중요한 것은 `요구사항을 변경할 때 오직 하나의 클래스만 수정`해도 된다는 것이다.

### 객체 합성이 클래스 상속보다 더 좋은 방법이다
- 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법은 `상속`이다.
  - 하지만 상속은 `코드 재사용을 위한 우아한 해결책이 아니다.`
  - 상속은 부모 클래스의 세부적인 구현에 `자식 클래스를 강하게 결합시키기 때문에 코드의 진화를 방해`한다.
- 코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 `합성`을 이용하는 것이다.
  - 상속이 구현을 재사용하는 데 비해 합성은 `객체의 인터페이스를 재사용`한다.


## 04. 믹스인
- 상속과 클래스를 기반으로 재사용 방법을 사용하면 클래스의 확장과 수정을 일관성 있게 표현할 수 있는 추상화의 부족으로 인해 변경하기 어려운 코드를 얻게 된다.
  - 따라서 구체적인 코드를 재사용하면서도 낮은 결합도를 유지할 수 있는 유일한 방법은 `재사용에 적합한 추상화를 도입`하는 것이다.
- `믹스인`
  - 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용한느 기법을 가리키는 용어다.
  - 합성이 `실행 지점에 객체를 조합하는 재사용 방법`이라면 믹스인은 `컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법`이다.
- 상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 `유연하게 관계를 재구성`할 수 있다.
  - 믹스인은 코드 재사용에 특화된 방법이면서도 `상속과 같은 결합도 문제를 초래하지 않는다.`
  - 믹스인은 `합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용`할 수 있는 방법이다.
- 하지만 처음 믹스인을 접하면 개념을 이해하기가 다소 어려울 수도 있는데 코드를 섞어 넣는다는 기본 개념을 구현하는 방법이 언어마다 다르기 때문이다.
  - 어떤 언어는 믹스인을 위한 구성 요소를 언어 차원에서 직접 지원하는 데 비해 어떤 언어는 다른 용도로 고안된 요소를 이용해 믹스인을 구현하기도 한다.
  - 그 방법이 무엇이건 `코드를 다른 코드 안에 유연하게 섞어 넣을 수 있다면 믹스인`이라고 부를 수 있다.

### 트레이드로 부가 정책 구현하기
- 상속은 정적이지만 믹스인은 동적이다.
  - 상속은 `부모 클래스와 자식 클래스의 관계를 코드를 작성하는 시점에 고정`시켜 버리지만 믹스인은 `제약을 둘뿐 어떤 코드에 믹스인될 것인지를 결정하지 않는다.`
  - 실제로 `트레이트를 믹스인하는 시점에 가서야 믹스인할 대상을 결정`할 수 있다.
- 상속의 경우에 `일반적으로 this 참조는 동적으로 결정되지만 super 참조는 컴파일 시점에 결정`된다.
  - 따라서 `상속에서는 부모 클래스와 자식 클래스 관계를 변경할 수 있는 방법은 없다.`
  - 하지만 `스칼라의 트레이트에서 super 참조는 동적으로 결정`된다.
  - 따라서 트레이트의 경우 this 호출뿐만 아니라 super 호출 역시 `실행 시점에 바인딩`된다.
- 이것이 트레이트를 사용한 믹스인이 클래스를 사용한 상속보다 `더 유연한 재사용 기법인 이유`다.
  - 상속은 재사용 가능한 문맥을 고정시키지만 `트레이트는 문맥을 확장 가능`하도록 열어 놓는다.
- 이런 면에서 `믹스인은 상속보다 합성과 유사`하다.
  - 합성은 `독립적으로 작성된 객체들을 실행 시점에 조합해서 더 큰 기능`을 만들어 내는 데 비해 믹스인은 `독립적으로 작성된 트레이트와 클래스를 코드 작성 시점에 조합해서 더 큰 기능`을 만들어낼 수 있다.

### 쌓을 수 있는 변경
- 믹스인은 `상속 계층 안에서 확장한 클래스보다 더 하위에 위치`하게 된다.
  - 다시 말해서 믹스인은 `대상 클래스의 자식 클래스처럼 사용될 용도`로 만들어지는 것이다.
  - 조합되기 위해 항상 상속 계층의 하위에 믹스인됐다는 것을 기억하라.
  - 따라서 믹스인을 `추상 서브 클래스`라고 부르기도 한다.
- 믹스인을 사용하면 `특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가`할 수 있다.