# 2장 객체지향 프로그래밍

## 01. 영화 예매 시스템
### 요구사항 살펴보기
![img.png](사진폴더/02/2.1%20할인%20정책과%20할인%20조건이%20지정된%20영화.png)

## 02. 객체지향 프로그래밍을 향해
### 협력, 객체, 클래스
- 진정한 객체지향 패러다임으로서의 전환은 클래스가 아닌 `객체에 초점`을 맞출 때에만 얻을 수 있다.
- 프로그래밍하는 동안 집중해야 하는 두 가지
  - `어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민`하라.
    - 클래스의 윤곽을 잡기 위해서는 `어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정`해야 한다.
    - 객체를 중심에 두는 접근 방법은 `설계를 단순하고 깔끔`하게 만든다.
  - `객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원`으로 봐야 한다.
    - 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재다.
    - 이것은 `설계를 유연하고 확장 가능`하게 만든다.
- `객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현`하라.

### 도메인의 구조를 따르는 프로그램 구조
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 `도메인`이라고 부른다.

![img.png](사진폴더/02/2.3%20영화%20예매%20도메인을%20구성하는%20타입들의%20구조.png)

- 객체지향 패러다임이 강력한 이유는 `요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용`할 수 있기 때문이다.
  - 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 `도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결`될 수 있다.
- 도메인 개념들을 구현하기 위해 클래스를 사용한다는 사실이 낯설지 않을 것이다.
  - 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.
  - 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.

### 클래스 구현하기
- 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 `어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것`이다.
- 클래스의 내부와 외부를 구분해야 하는 이유
  - `경계의 명확성이 객체의 자율성을 보장`하기 때문이다.
  - `프로그래머에게 구현의 자유를 제공`하기 때문이다.

### 자율적인 객체
- 두 가지 중요한 사실
  - 객체가 `상태`와 `행동`을 함께 가지는 복합적인 존재라는 것이다.
  - 객체가 `스스로 판단하고 행동하는 자율적인 존재`라는 것이다.
- 객체지향은 객체라는 단위 안에 `데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현`할 수 있게 했다.
  - 이처럼 데이터와 기능을 객체 내부로 함께 묶는 것을 `캡슐화`라고 한다.
- 대부분의 객체지향 프로그래밍 언어들은 캡슐화하는 것에서 한 걸음 더 나아가 외부에서의 접근을 통제할 수 있는 `접근 제어` 메커니즘도 함께 제공한다.
  - 접근 제어를 위해 public, protected, private과 같은 `접근 수정자`를 제공한다.
- 객체 내부에 대한 접근을 통제하는 이유는 `객체를 자율적인 존재로 만들기 위해`서다.
  - 객체지향의 핵심은 `스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것`이다.
- 캡슐화와 접근 제어는 두 부분으로 나눈다.
  - 외부에서 접근 가능한 부분으로 이를 `퍼블릭 인터페이스`라고 부른다.
  - 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 `구현`이라고 부른다.
  - `인터페이스와 구현의 분리` 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.
  
### 프로그래머의 자유
- 프로그래머의 역할을 `클래스 작성자`와 `클라이언트 프로그래머`로 구분하는 것이 유용하다.
  - `클래스 작성자는 새로운 데이터 타입을 프로그램에 추가`하고, `클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용`한다.
- 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다.
  - 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.
  - 이를 `구현 은닉`이라고 부른다.
- 구현 은닉은 `클래스 작성자와 클라이언트 프로그래머 모두에게 유용한 개념`이다.
  - 클라이언트 프로그래머는 내부의 구현을 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.
  - 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.
- 설계가 필요한 이유는 `변경을 관리하기 위해서`라는 것을 기억하라.
  - 객체의 변경을 관리할 수 있는 기법 중에서 가장 대표적인 것이 `접근 제어`다.
  - 변경될 가능성이 있는 세부적인 구현 내용은 `private 영역 안에 감춤으로써 변경으로 인한 혼란을 최소화`할 수 있다.

### 협력하는 객체들의 공동체
- 객체지향의 장점은 `객체를 이용해 도메인의 의미를 풍부하게 표현`할 수 있다는 것이다.
  - 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하라.
  - 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 `전체적인 설계의 명확성과 유연성을 높이는 첫걸음`이다.
  - 예) Long 타입을 사용하는 것이 아닌 금액과 관련한 Money 클래스 사용
- 시스템의 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 `협력`이라고 부른다.
  ![img.png](사진폴더/02/2.5%20Screening,%20Reservation,%20Movie%20사이의%20협력.png)
- 객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.

### 협력에 관한 짧은 이야기
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 `메시지를 전송`하는 것뿐이다.
- 다른 객체에게 요청이 도착할 때 해당 객체가 `메시지를 수신`했다고 이야기 한다.
- 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.
  - 이 처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 `메서드`라고 부른다.
- `메시지와 메서드를 구분하는 것은 매우 중요`하다.
  - 객체지향 패러다임이 유연하고, 확장 가능하며, 재사용 가능한 설계를 낳는다는 명성을 얻게 된 배경에는 메시지와 메서드를 명확하게 구분한 것도 단단히 한 몫한다.
    - 메시지와 메서드의 구분에서부터 `다형성`의 개념이 출발한다.


## 04. 상속과 다형성
### 컴파일 시간 의존성과 실행 시간 의존성
![img.png](사진폴더/02/2.7%20DiscountPlicy%20상속%20계층.png)
- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다는 것이다.
  - `클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.`
  - 그리고 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 `코드의 의존성과 실행 시점의 의존성이 다르다는 것`이다.
- 한 가지 간과해서는 안 되는 사실은 `코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것`이다.
  - 코드를 이해하기 위해서는 `코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문`이다.
  - 반면 `코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연하고 확장 가능`해진다.
- 이와 같은 `의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실`을 잘 보여준다.
- 훌륭한 객체지향 설계자로 성장하기 위해서는 `항상 유연성과 가독성 사이에서 고민`해야 한다.

### 차이에 의한 프로그래밍
- 상속은 `객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법`이다.
  - 상속을 이용하면 클래스 사이에 관계를 설정하는 것만으로 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 `차이에 의한 프로그래밍`이라고 부른다.

### 상속과 인터페이스
- 상속이 가치 있는 이유
  - `부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려 받을 수 있기 때문`이다.
  - 이것은 상속을 바라보는 일반적인 인식과는 거리가 있는데 `대부분의 사람들은 상속의 목적이 메서드나 인스턴스 변수를 재사용하는 것이라고 생각하기 때문`이다.
- 인터페이스는 `객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억`하라.
  - 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.
  - 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 `자식 클래스를 부모 클래스와 동일한 타입으로 간주`할 수 있다.
- 정리
  - `자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에 부모 클래스 대신 사용`될 수 있다.
  - 컴파일러는 코드 상에 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.
  - 자식 클래스가 부모 클래스를 대신하는 것을 `업캐스팅`이라고 부른다.

### 다형성
- 다시 한 번 강조하지만 `메시지와 메서드는 다른 개념`이다.
- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 `메시지를 수신하는 객체의 클래스가 무엇`이냐에 따라 달라진다.
  - 이를 `다형성`이라고 부른다.
- 다형성은 `객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반`으로 한다.
- 다형성은 `컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행`할 수 있게 한다.
- 다형성이란 `동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력`을 의미한다.
  - 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.
  - 즉, `인터페이스가 동일`해야 한다는 것이다.
  - 인터페이스를 통일하기 위해 사용한 구현 방법이 바로 `상속`이다.
- 다형성을 구현하는 방법은 매우 다양하지만 `메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점`이 있다.
  - 다시 말해 `메시지와 메서드를 실행 시점에 바인딩`하는 것이다.
  - 이를 `지연 바인딩` 또는 `동적 바인딩`이라고 부른다.


## 05. 추상화와 유연성
### 추상화의 힘
![img.png](사진폴더/02/2.13%20추상화는%20좀%20더%20일반적인%20개념들을%20표현한다.png)
- 추상화를 사용할 때의 장점
  - `추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다는 것`이다.
    - 추상화를 사용하면 `세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현`할 수 있다.
    - 이런 특징은 `세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명`할 수 있게 한다.
  - `추상화를 이용하면 설계가 좀 더 유연해진다는 것`이다.

### 유연한 설계
- `추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계`를 만들 수 있다.
  - 추상화가 유연한 설게를 가능하게 하는 이유는 `설계가 구체적인 상활에 결합되는 것을 방지하기 때문`이다.

### 코드 재사용
- 상속은 코드를 재사용하기 위해 널리 사용되는 방법이다.
  - 그러나 널리 사용되는 방법이라고 해서 가장 좋은 방법인 것은 아니다.
- 합성은 `다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법`을 말한다.

### 상속
- 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이다.
- 하지만 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
  - 가장 큰 문제점은 `상속이 캡슐화를 위반`한다는 것이다.
    - 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
    - 결과적으로 `부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화`된다.
    - 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다.
    - 결과적으로 `상속을 과도하게 사용한 코드는 변경하기도 어려워`진다.
  - `설계를 유연하지 못하게 만든다는 것`이다.
    - 상속은 `부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정`한다.
    - 따라서 `실행 시점에 객체의 종류를 변경하는 것이 불가능`하다.

### 합성
- 상속이 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 `강하게 결합`하는 데 비해 합성은 코드를 재사용(인터페이스)하여 `약하게 결합`된다는 것이다.
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 `합성`이라고 부른다.
- 합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.
  - 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 `캡슐화`할 수 있다.
  - 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 `설계를 유연`하게 만든다.
- 상속은 `클래스를 통해 강하게 결합`되는 데 비해 합성은 `메시지를 통해 느슨하게 결합`된다.
- 그렇다고 해서 `상속을 절대 사용하지 말라는 것은 아니다.`
  - `대부분의 설계에서는 상속과 합성을 함께 사용`해야 한다.
  - 코드를 재사용하는 경우에는 상속보다 합성을 선호하는 것이 옳지만 `다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용`할 수 밖에 없다.

### 정리
- `객체지향이란 객체를 지향`하는 것이다.
  - 따라서 `객체지향 패러다임의 중심에는 객체가 위치`한다.
- 객체지향에서 가장 중요한 것은 `애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용`이다.
  - 객체들은 `협력에 참여하기 위해 역할을 부여받고 역할에 적합한 책임을 수행`한다.
- 객체지향 설계의 핵심은 `적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당`하는 것이다.