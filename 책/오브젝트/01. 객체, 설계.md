# 1장 객체, 설계

## 01. 티켓 판매 애플리케이션 구현하기
![img.png](사진폴더/01/1.1%20애플리케이션의%20핵심%20클래스.png)

## 02. 무엇이 문제인가
### 예상을 빗나가는 코드
- 하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기 때문에 코드를 작성하는 사람뿐만 아니라 코드를 읽고 이해해야 하는 사람 모두에게 큰 부담을 준다.
  - 하지만 가장 심각한 문제는 이것이 아니다.
  - 그것은 Audience 와 TicketSeller 를 변경할 경우 Theater 도 함께 변경해야 한다는 사실이다.

### 변경에 취약한 코드
![img.png](사진폴더/01/1.2%20너무%20많은%20클래스에%20의존하는%20Theater.png)
- 이것은 객체 사이의 `의존성`과 관련된 문제다.
  - 문제는 의존성이 변경과 관련돼 있다는 점이다.
  - 의존성은 변경에 대한 영향을 암시한다.
    - 의존성이라는 말 속에는 `어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실`이 내포돼 있다.
- 그렇다고 해서 객체 사이이의 의존성을 완전히 없애는 것이 정답이 아니다.
  - `객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것`이다.
  - 따라서 우리의 목표는 `애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것`이다.
- 객체 사이의 의존성이 과한 경우를 가리켜 `결합도가 높다`라고 말한다.
  - 반대로 객체들이 합리적인 수준으로 의존할 경우에는 `결합도가 낮다`라고 말한다.
  - 결합도는 의존성과 관련돼 있기 때문에 결합도 역시 변경과 관련이 있다.
  - 따라서 설계의 목표는 `객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것`이어야 한다.


## 03. 설계 개선하기
### 자율성을 높이자
![img.png](사진폴더/01/1.6%20자율적인%20Audience와%20TicketSeller로%20구성된%20설계.png)
- 설계를 변경하기 어려운 이유는 Theater가 Audience와 TicketSeller 뿐만 아니라 Audience 소유의 Bag과 TicketSeller가 근무하는 TicketOffice까지 마음대로 접근할 수 있기 때문이다.
  - 해결 방법은 Audience와 TicketSeller가 직접 Bag과 TicketOffice를 처리하는 자율적인 존재가 되도록 설계를 변경하는 것이다.
- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 `캡슐화`라고 부른다.
  - 캡슐화의 목적은 `변경하기 쉬운 객체를 만드는 것`이다.
  - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.
- 객체를 인터페이스과 구현으로 나누고 인터페이스만을 공개하는 것은 `객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙`이다.
  
### 무엇이 개선됐는가
- 수정된 Audience와 TicketSeller는 자신이 가지고 있는 소지품을 스스로 관리한다.
  - 이것은 우리의 예상과도 정확하게 일치한다.
  - 따라서 코드를 읽는 사람과의 의사소통이라는 관점에서 이 코드는 확실히 개선된 것으로 보인다.
- 더 중요한 점은 Audience나 TicketSeller의 내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다는 것이다.
  - 따라서 수정된 코드는 변경 용이성의 측면에서도 확실히 개선됐다고 말할 수 있다.

### 어떻게 한 것인가
- 자기 자신의 문제를 스스로 해결하도록 코드를 변경한 것이다.
  - `우리는 우리의 직관을 따랐고 그 결과로 코드는 변경이 용이하고 이해 가능하도록 수정`됐다.

### 캡슐화와 응집도
- 핵심은 `객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것`이다.
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 `응집도가 높다`고 말한다.
  - 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 `결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.`
- `객체는 자신의 데이터를 스스로 처리하는 자율적인 존재`여야 한다.
  - 그것이 `객체의 응집도를 높이는 첫 걸음`이다.
  - 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 `훌륭한 객체지향 설계를 얻을 수 있는 지름길`인 것이다.

### 절차지향과 객체지향
- 절차지향
  - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 `절차적 프로그래밍`이라고 부른다.
    - 이것은 모든 처리가 하나의 클래스 안에 위치하고 나머지 클래스는 단지 데이터의 역할만 수행한다.
  - 절차적 프로그래밍은 `우리의 직관에 위배` 된다.
    - 절차적 프로그래밍의 세상은 우리의 예상을 너무나도 쉽게 벗어나기 때문에 코드를 읽는 사람과 원활하게 의사소통하지 못한다.
  - 절차적 프로그래밍의 세상에서는 `데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다는 것`이다.
  - 절차적 프로그래밍은 `프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점` 때문에 변경에 취약할 수밖에 없다.
- 객체지향
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 `객체지향 프로그래밍`이라고 부른다.
  - 훌륭한 객체지향 설계의 핵심은 `캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것`이다.
  - 객체지향 코드는 `자신의 문제를 스스로 처리해야 한다는 우리의 예상을 만족시켜주기 때문에 이해하기 쉽고`, `객체 내부의 변경이 객체 외부에 파급되지 않도록 제어할 수 있기 때문에 변경하기가 수월`하다.

### 책임의 이동
- 두 방식 사이에 근본적인 차이를 만드는 것은 `책임의 이동`이다.
  - 여기서 `책임`은 기능을 가리키는 객체지향 세계의 용어로 생각해도 무방하다.
- 두 방식의 차이점을 가장 쉽게 이해할 수 있는 방법은 `기능을 처리하는 방법을 살펴보는 것`이다.

  ![img.png](사진폴더/01/1.7%20책임이%20중앙집중된%20절차적%20프로그래밍.png)

  ![img.png](사진폴더/01/1.8%20책임이%20분산된%20객체지향%20프로그래밍.png)

- 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다.
  - 각 객체는 `자신을 스스로 책임`진다.
- 사실 객체지향 설계의 핵심은 `적절한 객체에 적절한 책임을 할당`하는 것이다.
  - 객체는 다른 객체와의 협력이라는 문맥 안에서 `특정한 역할을 수행하는 데 필요한 적절한 책임을 수행`해야 한다.
  - 객체가 어떤 데이터를 가지느냐보다는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞춰야 한다.
- 설계를 어렵게 만드는 것은 `의존성`이다.
  - 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 `결합도`를 낮추는 것이다.
  - `불필요한 세부사항을 캡슐화하는 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계`다.

### 더 개선할 수 있다
![img.png](사진폴더/01/1.9%20TicketOffice에서%20Audience로%20향하는%20의존성이%20추가된다.png)
- 자율적인 객체로 만들었지만 변경 전에는 존재하지 않았던 새로운 의존성이 추가된 것이다.
  - 의존성의 추가는 `높은 결합도를 의미`하고, 높은 결합도는 `변경하기 어려운 설계를 의미`한다.
- 여기서 알게된 두 가지 사실
  - 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
  - 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.
  - 어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들 수는 없다.
- 설계는 `균형의 예술`이다.
  - 훌륭한 설계는 적절한 트레이드오프의 결과물이라는 사실을 명심하라.

### 그래 거짓말이다!
- 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
  - 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 `의인화`라고 한다.
- 앞에서는 실세계의 생물처럼 스스로 생각하고 행동하도록 소프트웨어 객체를 설계하는 것이 이해하기 쉬운 코드를 작성하는 것이라고 설명했다.
  - 하지만 이제 말을 바꿔야겠다.
  - 훌륭한 객체지향 설계란 `소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계`를 가리킨다.


## 04. 객체지향 설계
### 설계가 왜 필요한가
- `설계란 코드를 배치하는 것`이다
- 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다.
  - 설계를 코드 작성의 일부이며 `코드를 작성하지 않고서는 검증할 수 없다.`
- 좋은 설계란?
  - 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야 한다.
    - 좋은 설계란 `오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계`다.
- 변경을 수용할 수 있는 설계가 중요한 이유는 `요구사항이 항상 변경`되기 때문이다.
  - 모든 요구사항을 수집할 수 있다고 가정하더라도 `개발이 진행되는 동안 요구사항은 바뀔 수밖에 없다.`
  - `코드를 변경할 때 버그가 추가될 가능성이 높기 때문`이다.

### 객체지향 설계
- 우리가 진정으로 원하는 것은 `변경에 유연하게 대응할 수 있는 코드`다.
  - 객체히쟝 프로그래밍은 `의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성`을 높여준다.
- `변경 가능한 코드란 이해하기 쉬운 코드`다.
- 객체지향 패러다임은 여러분이 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다.
  - 객체지향은 `여러분이 세상에 대해 예상하는 방식대로 객체가 행동하리라는 것을 보장함으로써 코드를 좀 더 쉽게 이해`할 수 있게 한다.
- 그러나 단순히 데이터와 프로세스를 객체라는 덩어리 안으로 밀어 넣었다고 해서 변경하기 쉬운 설계를 얻을 수 있는 것은 아니다.
  - 객체지향의 세계에서 애플리케이션은 `객체들로 구성되며 애플리케이션의 기능은 객체들 간의 상호작용을 통해 구현`된다.
  - 그리고 객체들 사이의 상호작용은 `객체 사이에 주고 받는 메시지로 표현`된다.
- 훌륭한 객체지향 설계란 `협력하는 객체 사이의 의존성을 적절하게 관리하는 설계`다.
  - 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워진다.
  - 객체 간의 의존성을 `애플리케이션을 수정하기 어렵게 만드는 주범`이다.